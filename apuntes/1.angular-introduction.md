# 1. ANGULAR 8


- [1. ANGULAR 8](#1-ANGULAR-8)
  - [1.1. Introducción](#11-Introducci%C3%B3n)
  - [1.2. Preparación del entorno](#12-Preparaci%C3%B3n-del-entorno)
    - [1.2.1. LOCALHOST Y EL SERVIDOR APACHE](#121-LOCALHOST-Y-EL-SERVIDOR-APACHE)
    - [1.2.2. NODE JS y NPM](#122-NODE-JS-y-NPM)
    - [1.2.3. ANGULAR 8 CLI](#123-ANGULAR-8-CLI)
    - [1.2.4. Visual Studio Code](#124-Visual-Studio-Code)
  - [1.3. Creación de un proyecto en Angular 8](#13-Creaci%C3%B3n-de-un-proyecto-en-Angular-8)
    - [1.3.1. Primer Proyecto](#131-Primer-Proyecto)
    - [1.3.2. La estructura de archivos](#132-La-estructura-de-archivos)
    - [1.3.3. Arrancar la aplicación](#133-Arrancar-la-aplicaci%C3%B3n)
    - [1.3.4. Lo que se carga en el navegador](#134-Lo-que-se-carga-en-el-navegador)
    - [1.3.5. Agregar librerías de terceros](#135-Agregar-librer%C3%ADas-de-terceros)
    - [1.3.6. Estructura de una aplicación Angular 8](#136-Estructura-de-una-aplicaci%C3%B3n-Angular-8)
  - [1.4. Creación de Componentes](#14-Creaci%C3%B3n-de-Componentes)

## 1.1. Introducción

Framework de JavaScript desarrollado por Google muy utilizado en desarrollo web.
Angular es un entorno de trabajo pensado para el desarrollo de lo que se conoce como **SPA** (Single Page Application, o Aplicaciones de una Sola Página). Esto quiere decir que las aplicaciones en Angular tienen una única página, en la que se van cargando las distintas vistas que necesitemos. De cara al usuario, no altera su forma habitual de navegación aunque, gracias a esta tecnología, le ofrece mayor velocidad de carga y una forma de carga de las páginas más racionalizada.
La versión más actualizada de Angular es la 8. En este curso trabajaremos con la versión 7, haciendo algunas puntualizaciones:
- Todo  lo que se exponga será compatible con versiones anteriores
- Todas las versiones de Angular se están empleando todavía. Incluso se inician aplicaciones en versiones anteriores.
- Haremos un upgrade a la última versión de Angular

## 1.2. Preparación del entorno

En nuestro ordenador, deberemos tener lo siguiente:
-  Un directorio de trabajo como localhost.
- Un servidor Apache.
- El Node JS + NPM.
- Angular 8 CLI.
- Un editor de texto plano o un IDE.
- Y, un navegador. Se recomienda usar Chrome, aunque, una vez hecho y depurado un desarrollo, se debe probar en distintos navegadores, para asegurarnos de que funciona sin problemas en todos ellos.

### 1.2.1. LOCALHOST Y EL SERVIDOR APACHE

Cualquier desarrollador web tiene que tener, sean cuales sean las tecnologías de desarrollo que emplee, un servidor web montado en modo local (localhost), para su trabajo diario. Si bien es cierto que hay algunos recursos que, por su propia naturaleza, sólo pueden ser probados contra un servidor remoto, en la inmensa mayoría de los casos, los desarrollos y las pruebas preliminares siempre se harán en local. Dependiendo del sistema operativo existen distintas alternativas para instalar Apache. Existen soluciones paquetizadas que lo instalan junto con PHP y MySQL, y que resultan muy prácticas (wamp o xampp en entornos Windows, mamp en entornos Mac). Lo usuarios de Linux suelen instalar estas herramientas al montar su distro. 

### 1.2.2. NODE JS y NPM

Node JS es, principalmente, una herramienta para desarrollo de programación back-end en JavaScript. Para trabajar con Angular 8 no se necesita dominar Node.JS, aunque sí que esté instalado. Básicamente porque necesitamos obligatoriamente el gestor de paquetes de Node: **NPM** (Node Package Manager). NPM permite instalar Angular y librerías complementarias que se puedan necesitar.

**Instalación**

1. Verificar si Node.JS está instalado. Para ello, desde un terminal de comandos del sistema operativo teclear: `node -v` Si está correctamente instalado, devolverá el número de versión de node. 
   Si no, devolverá un mensaje de error, indicando que no se reconoce el comando node. 

2. En ese caso,  descargar desde la web oficial de [Node.JS]( https://nodejs.org/es/). 
:warning: En la web oficial existen dos enlaces para descargar Node. El de la izquierda es la versión **LTS** (Long Term Support). Es la última versión probada, depurada, y asistida por soporte del fabricante. A la derecha encuentras el enlace de la última versión que han publicado. Esta suele ser una beta, o una RC, y podría tener bugs o detalles que necesiten ser configurados de forma manual. 

3. **Descargar** el instalador de la **versión LTS** e instalar. Con esto se instala también **NPM**.

### 1.2.3. ANGULAR 8 CLI

Para trabajar con Angular 8 y desarrollar proyectos con esta herramienta se necesita tener instalado **Angular 8 CLI**. CLI son las siglas de **Command Line Interface** (Interface de Línea de Comandos). 

Para saber si está instalado se teclea:

`ng version`

Si está instalado devolverá el número de versión disponible. Si no, se deberá instalar con:

```
npm install -g @angular/cli
```
o, abreviadamente,
```
npm i -g @angular/cli
```

Ambos comandos instalarán la última versión de Angular (en este caso Angular 8)

Para instalar otra versión anterior de Angular se debería teclear:

`npm i -g @angular/cli@<num de la version>`

### 1.2.4. Visual Studio Code

Es el interfaz de desarrollo ( IDE ) de Microsoft que, además de ser gratuito, permite implementar gran cantidad de plugins.

Existen multitud de editores, todos ellos son perfectamente utilizables (WebStorm, NetBeans, Sublime Text...). Algunos son de pago, y otros gratuítos. 

Para instalar Visual Studio Code se descarga de su [página oficial](https://code.visualstudio.com).

**Instalación de extensiones**
Las extensiones o plugins amplian las funcionalidades de Visual Studio Code (VSC), para facilitar el trabajo diario. Al abrir VSC tiene, por defecto, un aspecto similar al siguiente:

![vsc](https://code.visualstudio.com/assets/home/home-screenshot-win.png)

 Se puede observar en la barra lateral a la izquierda del área de trabajo una serie de cinco botones. Pulsando el botón que tiene forma cuadrada: ![extensions](https://imgur.com/fh34PLp.png), aparecerá una lista de las extensiones instaladas. En la parte superior de la lista aparece un campo de texto donde se puede teclear el nombre de una extensión, y VSC la buscará en la página oficial, desde donde se puede instalar.
Aunque la extensión se busca en Internet, VSC la muestra en el área de trabajo, con un botón específico para instalarla, así como algunas instrucciónes para usarla, que se recomienda leer, aunque sea por encima. Siempre se puede volver al instalador, y pedir una extensión ya instalada, para ver esas instrucciones.
Las extensiones que se pueden instalar, por el momento son:

- **Color Picker**. Se trata de una extensión que permite abrir un selector de color y, una vez elegido uno de ellos, incluye, en el código que se está editando, el valor de ese color.
- **Angular Essential**s. Es una extensión con varias funcionalidades integradas para desarrollo en Angular. Permite detectar con mayor facilidad errores de sintaxis, autocompletar código, detectar ciertos errores en TypeScript, etc.
- **TS Lint**. También permite detectar errores de sintaxis o de prácticas de programación en TypeScript. Aunque la extensión anterior ya incorpora un TS Linter, no está de más instalar, específicamente, esta extensión. Type Script juega un papel fundamental en el desarrolo con Angular. 

## 1.3. Creación de un proyecto en Angular 8

Un proyecto en Angular 8 se crea a partir de una estructura de archivos que son gestionados por el Angular CLI.

Con Angular se trabaja en tres modos fundamentales:
- **Desarrollo**. Es el modo de trabajo en el que se crean las páginas y contenidos del proyecto.
- **Test**. Es un modo específico para realizar test unitarios y de integración.
- **Producción**. A partir del código creado en desarrollo, se generan las páginas que se subirán al servidor, para ponerlas a disposición de los usuarios del proyecto.
  
### 1.3.1. Primer Proyecto

Desde el directorio raíz de los proyectos web, es decir, el que se corresponde con localhost, se teclea en el terminal de comandos, lo siguiente:

`ng new prueba-angular --prefix pr --minimal true --routing true`

o, abreviadamente,

`ng new prueba-angular -p pr -m true --routing true`

El comando tiene las siguientes partes:

- **ng** es el mandato de terminal para muchas operaciones en el entorno de Angular 8.
- **new** *prueba-angular*: indica a *ng* que se va a crear un proyecto nuevo, llamado prueba-angular. El **CLI** (invocado por ng) se ocupará de crear un directorio llamado prueba-angular, y colocar, dentro de este, la estructura básica de archivos.
- **--prefix** pr o su abreviación **-p** pr indica un prefijo que llevarán los nombres de distintos elementos del proyecto. Aunque este parámetro sea, técnicamente, opcional, en la práctica resulta imprescindible para ayudar a organizar las etiquetas y otros elementos del proyecto. El prefijo es arbitrario y sería recomendable utilizar las iniciales del proyecto, o las del cliente para el que se esté trabajando, etc, 
- **-- minimal** *true* o, abreviadamente, **-m** *true* le indica al CLI que se va a desarrollar un proyecto con las funcionalidades básicas de Angular. Por ejemplo, creando un proyecto no se encuentran disponibles los test unitarios o de integración. Con esta opción, todo el código (html, css y JavaScript) se incluye en el mismo archivo.
- **-- routing** *true*. Con esta opción se indica al CLI que se va a usar el sistema de enrutamiento de Angular 8.

Con este comando, se crea un nuevo directorio llamado prueba-angular y, dentro de él, la estructura básica de un proyecto en Angular 8. El proceso puede llevar varios minutos, dependiendo de la velocidad de la conexión, y de las capacidades del equipo. Tras este lapso, y varios mensajes en pantalla, la instalación finaliza con ***Project 'prueba-angular' successfully created***. Esta es la estructura básica del proyecto.

:warning: Para ver una lista de las opciones de creación de proyectos se puede consultar https://github.com/angular/angular-cli/wiki/new.

### 1.3.2. La estructura de archivos

La carpeta del proyecto *prueba-angular* tiene la siguiente estructura:
- **`node_modules`**: directorio donde npm instala todas las dependencias de Angular.
- **`src`**:  contiene los archivos base del proyecto. En ese directorio se coloca todo el código Angular (HTML, TypeScript, CSS, etc).
- **`angular.json`** archivo de configuración del CLI para este proyecto. Antes de la versión 6 se llamaba .angular-cli.json.
- **`package.json`** archivo de dependencias y comportamiento del proyecto.
- **`tsconfig.json`**: configuración de TypeScript. 
 
**EL ARCHIVO package.json**

Este archivo ha sido generado por npm. Contiene la lista de dependencias que necesita el proyecto (y contendrá otras dependencias que se instale a posteriori). Su listado, por defecto, es el siguiente:

```javascript
{
  "name": "prueba-angular",
  "version": "0.0.0",
  "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build",
    "test": "ng test",
    "lint": "ng lint",
    "e2e": "ng e2e"
  },
  "private": true,
  "dependencies": {
    "@angular/animations": "~7.2.0",
    "@angular/common": "~7.2.0",
    "@angular/compiler": "~7.2.0",
    "@angular/core": "~7.2.0",
    "@angular/forms": "~7.2.0",
    "@angular/platform-browser": "~7.2.0",
    "@angular/platform-browser-dynamic": "~7.2.0",
    "@angular/router": "~7.2.0",
    "core-js": "^2.5.4",
    "rxjs": "~6.3.3",
    "tslib": "^1.9.0",
    "zone.js": "~0.8.26"
  },
  "devDependencies": {
    "@angular-devkit/build-angular": "~0.13.0",
    "@angular/cli": "~7.3.9",
    "@angular/compiler-cli": "~7.2.0",
    "@angular/language-service": "~7.2.0",
    "@types/node": "~8.9.4",
    "ts-node": "~7.0.0",
    "tslint": "~5.11.0",
    "typescript": "~3.2.2"
  }
}

```

En el primer aparecen metadatos, como el nombre del proyecto, o su versión. Son datos documentativos, que se pueden modificar libremente.
Bajo el apartado `scripts` se encuentran algunos comandos de ng, que se invocarán desde npm. 
En el apartado `dependencies` se encuentran las referencias a las dependencias que se instalan por defecto cuando se crea un nuevo proyecto, y que deben estar disponibles tanto en modo de desarrollo como en producción. Existen dos grandes grupos:
- Las dependencias propias de angular, que son aquellas cuyo nombre empieza por @. 
- El resto (en este caso core.js, rxjs y zone.js) que son librerías de terceros que, por su naturaleza, se han convertido en parte imprescindible de cualquier proyecto Angular.
  
Por último, en el apartado `devDependencies` se encuentran dependencias de librerías, propias de Angular o de terceros, que sólo son necesarias durante el desarrollo, y que no deben de estar disponibles cuando se pase el proyecto a producción. Un ejemplo es el uso de TypeScript que se usa durante el desarrollo, pero luego el código se transpila a JavaScript, que es lo que realmente entiende el navegador.

**EL DIRECTORIO src**

Este directorio contiene toda la aplicación Angular. Es decir, todo el HTML, el TypeScript (que se transpilará a JavaScript) y el CSS.
Aparece el archivo **index.html** que es el punto de entrada de la aplicacion. El código es el siguiente:

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>PruebaAngular</title>
  <base href="/">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <pr-root></pr-root>
</body>
</html>
```

Este fichero HTML sólo tiene una etiqueta que se abre y cierra en la misma línea, resaltada en el listado. El nombre de la etiqueta empieza por *pr-*, que es el prefijo que se estableció al crear el proyecto, con el modificador --prefix (o -p, en su versión abreviada) serían las siglas para identificar elementos de la aplicación Angular. En el espacio de estas etiquetas se incluirá la plantilla recogida en el archivo **app.component.ts**, dentro de
del directorio **src/app**.

### 1.3.3. Arrancar la aplicación

Teclear dentro del terminal de VSC lo siguiente:

`npm start`

Se lanza el mandato ng serve y, tras unos segundos, se lleva a cabo una transpilación de TypeScripts a JavaScripts. Cuando termina, aparece la siguiente línea:

** NG Live Development Server is listening on localhost:4200, open your browser on http://localhost:4200/ **

Y, tecleando desde el navegador: http://localhost:4200/

Se verá la siguiente página:

![](https://imgur.com/247mg32.png)

El resultado corresponde con el HTML definido en **app.component.ts**. El listado completo es:

```javascript

import { Component } from '@angular/core';
  @Component({
   selector: 'pr-root',
   template: `
     <!--The content below is only a placeholder and can be replaced.-->
     <div style="text-align:center">
       <h1>
         Welcome to {{title}}!
       </h1>
       <img width="300" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTAgMjUwIj4KICAgIDxwYXRoIGZpbGw9IiNERDAwMzEiIGQ9Ik0xMjUgMzBMMzEuOSA2My4ybDE0LjIgMTIzLjFMMTI1IDIzMGw3OC45LTQzLjcgMTQuMi0xMjMuMXoiIC8+CiAgICA8cGF0aCBmaWxsPSIjQzMwMDJGIiBkPSJNMTI1IDMwdjIyLjItLjFWMjMwbDc4LjktNDMuNyAxNC4yLTEyMy4xTDEyNSAzMHoiIC8+CiAgICA8cGF0aCAgZmlsbD0iI0ZGRkZGRiIgZD0iTTEyNSA1Mi4xTDY2LjggMTgyLjZoMjEuN2wxMS43LTI5LjJoNDkuNGwxMS43IDI5LjJIMTgzTDEyNSA1Mi4xem0xNyA4My4zaC0zNGwxNy00MC45IDE3IDQwLjl6IiAvPgogIDwvc3ZnPg==">
     </div>
     <h2>Here are some links to help you start: </h2>
     <ul>
       <li>
         <h2><a target="_blank" rel="noopener" href="https://angular.io/tutorial">Tour of Heroes</a></h2>
       </li>
       <li>
         <h2><a target="_blank" rel="noopener" href="https://github.com/angular/angular-cli/wiki">CLI Documentation</a></h2>
       </li>
       <li>
         <h2><a target="_blank" rel="noopener" href="https://blog.angular.io/">Angular blog</a></h2>
       </li>
     </ul>
     <router-outlet></router-outlet>
   `,
   styles: []
 })
 export class AppComponent {
   title = 'pr';
 }
```

**APP.COMPONENT.TS**

Son los elementos que Angular incluye en el **index.html**, o en otras partes de la aplicación, y que generan el resultado que se renderiza en el navegador. Se identifica mediante el selector (línea 4 del código) que coincide con la etiqueta HTML.
Como norma general, un componente tiene tres bloques claramente distinguibles:

- **Librerías necesarias** para que funcione el componente. Corresponde con los elementos *import*.
  
- **Código del componente**. Es el bloque principal, que aparece entre *@Component* ({ (en la línea 3) y }) (en la línea 28). Estos bloques se conocen, genéricamente, con el nombre de decoradores y contienen lo que el componente debe generar.
- **Salida del componente**. El componente es, en realidad, una clase que se exporta mediante el comando export de TypeScript (de ES6, para ser exactos). Al punto donde se llamó a la etiqueta que coincide con el selector mencionado anteriormente.

Dentro del archivo **package.json**, se puede ver lo siguiente:

`"start": "ng serve",`

Sirve para que, cuando npm ejecuta el comando start, lo que hace es llamar a ng serve. Se puede modificar para que arranque directamente el navegador:

`"start": "ng serve -o --port 4500"`

La opción `--open` (abreviadamente, -o). Hace que, cuando se arranque el servidor, se abra automáticamente el navegador por defecto y se cargue la aplicación Angular, 

La opción `--port` permite cambiar el puerto de escucha de la aplicación.

### 1.3.4. Lo que se carga en el navegador

Una vez arrancada la aplicación, abriendo el inspector de la página se ve lo siguiente:

```html
<!doctype html>
 <html lang="en">
 <head>
   <meta charset="utf-8">
   <title>PruebaAngular</title>
   <base href="/">
    <meta name="viewport" content="width=device-width, initial-scale=1">
   <link rel="icon" type="image/x-icon" href="favicon.ico">
 </head>
 <body>
   <pr-root></pr-root>
 <script type="text/javascript" src="inline.bundle.js"></script><script type="text/javascript" src="polyfills.bundle.js"></script><script type="text/javascript" src="styles.bundle.js"></script><script type="text/javascript" src="vendor.bundle.js"></script><script type="text/javascript" src="main.bundle.js"></script></body>
 </html>
```

**No hay código HTML** que genere los contenidos que se ven. Aparece la etiqueta `<pr-root></pr-root>` y unas llamadas a archivos JavaScript. Estos son el resultado de haberse transpilado los TypeScripts correspondientes, y son los que colocan el contenido de la página, de forma dinámica (por eso no se ve en el código fuente), entre `<pr-root>` y `</pr-root>`. En la pestaña Elements del inspectorse observa el código completo, como si se hubiera escrito directamente en el HTML.

### 1.3.5. Agregar librerías de terceros

Algunos ejemplos de librerías instalables en el proyecto:
```
npm install --save jquery
npm install --save moment
npm install --save milligram
npm install --save bootstrap
```

En el apartado dependencies de **package.json**:

```javascript
"dependencies": {
 	"@angular/animations": "^5.2.0",
 	"@angular/common": "^5.2.0",
 	"@angular/compiler": "^5.2.0",
 	"@angular/core": "^5.2.0",
 	"@angular/forms": "^5.2.0",
 	"@angular/http": "^5.2.0",
 	"@angular/platform-browser": "^5.2.0",
 	"@angular/platform-browser-dynamic": "^5.2.0",
 	"@angular/router": "^5.2.0",
 	"bootstrap": "^4.1.1",
 	"core-js": "^2.4.1",
 	"jquery": "^3.3.1",
 	"milligram": "^1.3.0",
 	"moment": "^2.22.1",
 	"rxjs": "^5.5.6",
 	"zone.js": "^0.8.19"
 },
 ```

Se han añadido las correspondientes dependencias.
En la carpeta node_modules, el gestor de paquetes npm ha instalado las librerías de terceros. Estas librerías son necesarias referenciarlas en el archivo `angular.json`, situado en la raíz del proyecto, para que estén disponibles. Dentro de las claves:
```
"styles": [
   "./node_modules/bootstrap/dist/css/bootstrap.min.css",
   "./node_modules/milligram/dist/milligram.min.css",
   "styles.css"
 ],
 "scripts": [
   "./node_modules/jquery/dist/jquery.min.js",
   "./node_modules/bootstrap/dist/js/bootstrap.min.js",
   "./node_modules/moment/min/moment.min.js"
 ],
 ```

**EL FICHERO angular.json**

Dentro del fichero angular.json se encuentran definidas las siguientes propiedades:

- Dentro de **`project`** encontramos la clave `name`, que contiene el nombre con el que se crea el proyecto. 
- Dentro de **`apps`** se encuentra:
  - La clave `root` contiene el nombre del directorio donde se desarrolla la aplicación. Por defecto es `src`, aunque puede variar si se cambia el nombre del directorio.
   -La clave `outDir` contiene el nombre del directorio donde se almacenará la aplicación cuando se compile la versión para producción. Por defecto es **dist**.
  - La clave `index` contiene el nombre de la página principal, que es **index.html**.
  - Las claves `main`, `polyfills`, `test`, `tsconfig` y `testTsconfig` contienen los nombres de cinco archivos TypeScript, que no se deben modificar.
  -	La clave `prefix` contiene el prefijo con el que se creó el proyecto, al usar el comando `ng new`.
  -	La clave `styles` contiene el nombre del archivo de estilos css que, por defecto, se crea vacío.

**LOS POLYFILLS**

Los polyfills son herramientas que permiten que ciertos navegadores (Internet Explorer) se comporten correctamente ante los CSS y los JavaScripts que se generan con Angular. El archivo polyfills.ts contiene llamadas a polyfills para que funcionen determinadas prestaciones en los navegadores IE9, IE10, IE11 y Edge. Por defecto, aparecen comentados.

### 1.3.6. Estructura de una aplicación Angular 8


**WEBPACK**. 
Webpack es una herramienta que forma parte del CLI de Angular 8. Es un "constructor de bundles", es decir, el encargado de colocar el JavaScript generado durante la transpilación en los archivos JavaScript correspondientes. Así, por ejemplo, el JavaScript propio de Angular, se colocará en los archivos inline.bundle.js, polyfills.bundle.js, styles.bundle.js y vendor.bundle.js, mientras que el JavaScript que provenga del desarrollo se colocará en main.bundle.js. 
Durante el desarrollo, estos archivos no existen en la carpeta del proyecto, sino que son generados por el webpack y viven, únicamente, en el entorno del navegador. Cuando se hable de despliegue para producción, las cosas cambiarán un poco, pero los fundamentos son los mismos.

**LA ESTRUCTURA DE ARCHIVOS**

En el directorio **`src`** está el directorio **`app`**, que contiene: 
- **app.module.ts**, contiene la clase `AppModule` que es el módulo principal de la aplicación. 
-	**app-routing.module.ts**. Se usará para programar los enrutamientos cuando se creen otros módulos y componentes y haya que usar enlaces.
-	**app.component.css**. Este archivo incluye los estilos de la aplicación.
-	**app.component.html**. 
-	**app.component.spec.ts** para los test unitarios y de integración.
-	**app.component.ts**. contiene la propiedad `templateURL`, que referencia al archivo de html. `styleUrls`, apunta a una matriz con los nombres de los archivos de estilo. Por defecto, sólo hay uno (app.component.css).




Una aplicación Angular está formada por dos tipos básicos de elementos: los **componentes** y los **servicios**. Estos, a su vez, se agrupan en **módulos**. Además, como en cualquier aplicación web existen enlaces que nos llevan de un contenido a otro, hay un sistema de **enrutamiento** que permite saltar de un módulo a otro. A grandes rasgos, el esquema de una aplicación web desarrollada con Angular puede parecerse al siguiente:

![](https://imgur.com/bMQWqnn.png)

Este esquema está muy resumido, ya que, dentro de los módulos, se puede encontrar, por ejemplo, otros enrutadores que permitan acceder a distintos componentes o servicios del módulo, o de otros módulos. La estructura final puede ser tan compleja como lo requiera la aplicación. 

**EL MÓDULO**

El componente está encapsulado en un módulo. Dentro del directorio app existe un archivo llamado **app.module.ts**. La página index.html no accede directamente al componente. Como el componente está encapsulado en el módulo, la página accede al componente dentro del módulo. El listado del fichero app.module.ts es el siguiente:

```javascript

/* Estos son las instrucciones JavaScript para importar ficheros. 
Angular no maneja nada de esto. */

import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';

/* El decorador @NgModule permite a Angular reconocer que éste es 
un NgModule. */

   @NgModule({
   declarations: [
     AppComponent
   ],

   /* Estos son los imports de NgModule. */

   imports: [
     BrowserModule,
     AppRoutingModule
   ],
   providers: [],
   bootstrap: [AppComponent]
 })
 export class AppModule { }
 ```

Es cierto que cuando una etiqueta HTML llama a un componente (que es el que tiene el código), lo relaciona a través del **selector** que coincide con la etiqueta. Sin embargo, como el componente está encapsulado en el módulo, hay que pasar "a través" de esta envoltura.

- En primer lugar, se importan dos elementos propios de Angular. Uno de ellos es el **BrowserModule**, que permite que la aplicación corra en los navegadores, y el otro es el **NgModule**, que permite definir qué es lo que "maneja" el módulo. Estos elementos se importan desde carpetas del propio Angular, que se encuentran en **node_modules**, dentro de **@angular**. 
- En la línea 4 se importa el **AppRoutingModule**. Esto no está dentro de node_modules, sino en la carpeta **app**, por lo que aparece como una ruta relativa. Esto hace referencia al enrutamiento dentro del módulo.
- A continuación se importa el componente que se va a usar (**AppComponent**).
- En el fichero app.component.ts las tres últimas líneas son las siguientes:

  ```
    export class AppComponent {
      title = "mi primer angular";
    }
  ```

**En Angular todo son clases**: los módulos, los componentes que hay dentro... todo. El módulo importa una clase que es exportada por el componente.

Siguiendo con el fichero app.module.ts, lo siguiente que se encuentra, entre las líneas 9 y 19 es lo que se llama el **decorador**. Un decorador es una función de Angular, con su nombre precedido con el signo @, que aporta operativa a la clase con la que se está trabajando.  El array de **imports** del decorador `@NgModule` le dice a Angular que otros NgModules necesita.

Dentro del decorador se encuentra la clave **declarations**. En ella se referencian los componentes que se usan en este módulo, y que tienen que haber sido importados en la sección de imports. En este caso, sólo es AppComponent, porque este componente es lo único que existe por el momento.

También dentro del decorador se encuentra la clave **imports**. Bajo este epígrafe se declaran las importaciones que son necesarias para que este módulo funcione correctamente. En este caso son dos: **BrowserModule** y **AppRoutingModule**. Son dos de las importaciones que se hacen al principio, antes del propio decorador. Lo de BrowserModule es bastante intuitivo; Angular lo necesita para entenderse con el navegador. AppRoutingModule, aparece al usar el modificador --routing true. 

La clave **providers** está vacía hasta que se trabaje con servicios.

La clave **bootstrap**, que puede traducirse por "arranque" o "inicio", almacena una matriz con los nombres de los componentes que tienen que cargarse cuando se inicia el módulo. Como, en este caso, sólo existe uno (AppComponent) ese es el que aparece aquí.
Finalmente, en la línea 20, el módulo se exporta como una clase (**En Angular todo son clases**). El módulo se exporta para que pueda ser recogido, en este caso, por el HTML. Así se relaciona el módulo que importa el componente y, a través de su propiedad selector, con una etiqueta del HTML.

**¿POR QUÉ AppModule?**

Es el módulo principal, que aparece así considerado en el archivo `main.ts`:
```javascript
import { enableProdMode } from '@angular/core';
 import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
  import { AppModule } from './app/app.module';
 import { environment } from './environments/environment';
  if (environment.production) {
   enableProdMode();
 }
  platformBrowserDynamic().bootstrapModule(AppModule)
   .catch(err => console.log(err));
   ```

En la línea 11 indica que el módulo de arranque (bootstrapModule) es, precisamente, AppModule, que se importa completo en la línea 4.

## 1.4. Creación de Componentes

Las funcionalidades de una aplicación Angular se crean en componentes y estos se encapsulan en módulos.

**En el ejemplo se creará un componente para utilizarlo en la página principal, o en cualquier otra vista del sitio.**

De momento, se creará dentro del módulo principal (AppModule), que es el que creó el CLI por defecto.

Para crear un nuevo se usa el comando **ng**, en este caso con la instrucción **generate** y especificando que se quiere crear un **component** y el nombre del componente. Este componente se creará dentro del módulo existente (AppModule). 

:reminder_ribbon:  **Todos los componentes se disponen encapsulados en módulos**.

El componente funcionará de cabecera, y se llamará **header**. Aparecerá en todas las vistas de la aplicación.

:warning: "Vistas de la aplicación", y no "las páginas del sitio", por ejemplo. Angular 8 es un framework orientado a la creación de lo que se conoce como SPA's (Single Page Applications, o Aplicaciones de Una Sola Página). Es decir, la aplicación sólo tiene una página que es **index.html**. Las distintas vistas se cargarán siempre en esa página y, aunque cada vista tendrá su propia URL específica, eso es algo que Angular gestionará internamente, pero la página siempre será la misma.

`ng generate component header`

o, abreviadamente:

`ng g c header`

Este comando crea el componente **header** que será visible en todos los demás componentes que luego se creen en el mismo módulo. Sin embargo, para poder utilizar esta cabecera en componentes de otros módulos el comando debe llevar el modificador `-export`:

`ng generate component header --export`

o bien:

`ng g c header --export`

Tecleando en el terminal de VSC esta instrucción. La respuesta de la terminal es:

```create src/app/header/header.component.html (25 bytes)
 create src/app/header/header.component.spec.ts (628 bytes)
 create src/app/header/header.component.ts (269 bytes)
 create src/app/header/header.component.css (0 bytes)
 update src/app/app.module.ts (507 bytes)
```

Informa de que se han creado cuatro archivos, y se ha actualizado app.module.ts, es decir, la envoltura del módulo. Los cuatro archivos se han creado dentro de un directorio llamado header (que es el nombre dado al componente) que, a su vez, ha quedado alojado en en src/app/. Los cuatro archivos creados son:

- **header.component.html**. Contendrá el código HTML del componente. Por ahora, "de fábrica", sólo incluye un párrafo de texto, para comprobar que funciona.
- **header.comoponent.spec.ts**. Archivo para los test unitarios y de integración, si el componente los necesitara. 
- **header.component.ts**. Alojará toda la lógica TypeScript (que luego será transpilada a JavaScript) del componente. De momento, tiene sólo la estructura básica.
- **header.component.css**. Este archivo almacenará los estilos que se quieran usar en el componente. Por defecto está vacío. Una puntualización; los estilos definidos en este componente no interferirán (no colisionarán) con estilos definidos para otros componentes, aunque tengan los mismos nombres.

Además, la envoltura del módulo (app.module.ts) ha sufrido algunas actualizaciones, para "reconocer" el nuevo componente. El código quedaría:

```javascript
import { BrowserModule } from '@angular/platform-browser';
 import { NgModule } from '@angular/core';
  import { AppRoutingModule } from './app-routing.module';
  import { AppComponent } from './app.component';
 import { HeaderComponent } from './header/header.component';
   @NgModule({
   declarations: [
     AppComponent,
     HeaderComponent
   ],
   imports: [
     BrowserModule,
     AppRoutingModule
   ],
   providers: [],
   bootstrap: [AppComponent],
   exports: [HeaderComponent]
 })
 export class AppModule { }
```

En la primer línea resaltada (la 7) se importa el nuevo componente. En la línea 13 se ha incluido en la propiedad declarations. Por último, dado que el componente se ha creado con el modificador --export, para poder usarlo luego desde otros módulos, en la línea 21 el nombre del componente se ha incluido en la propiedad exports que, hasta ahora, no existía.

**Prueba del componente**

`npm start` desde el terminal y INTRO. 

El componente header no parece estar funcionando porque falta modificar el archivo **app.component.html**. Primero se sustituye el código de muestra por:

```html
<h1>
   Página principal de la aplicación
 </h1>
 <router-outlet></router-outlet>
```
Después se incluye el selector del componente header dentro de la plantilla anterior:

```html
<a01-header></a01-header>
 <h1>
   Página principal de la aplicación
 </h1>
 <router-outlet></router-outlet>
```

**Personalización del componente**

Para que el componente header, se parezca más a una cabecera de una aplicación. En primer lugar, se modifica el archivo header.component.html, dejándolo así:

<header>
   <h1>Cabecera de la aplicación</h1>
</header>

Y se añaden estilos en el archivo header.component.css:

```css
header {
  padding: 2rem;
  top: 0;
  left: 0;
  right: 0;
  background-color: #00b4b3;
}
h1 {
   color: #840101;
}
```

A continuación se añaden estilos al AppComponent dentro del archivo app.component.css, así:

```css
h1 {
   margin-left: 4rem;
 }
```

Por último, se modifica el archivo de estilos general del sitio (styles.css), dentro del directorio src, al mismo nivel que index.html. 
Su contenido queda así:

/* You can add global styles to this file, and also import other style files */

```css 
body{
   margin-top: 0;
   margin-left: 0;
   margin-right: 0;
 }
```

Una vez guardados los cambios se puede comprobar que los estilos de un componente no colisionan con los de otro. Los estilos de `<h1>` definidos para AppComponent y para HeaderComponent son diferentes, y cada `<h1>` muestra sus propios estilos. Esta es la encapsulación que realiza Angular.

**Nomenclatura de los componentes**

- En primer lugar, el nombre no debe colisionar con ningún nombre de componente de Angular. Si lo hiciera, podría haber problemas con la aplicación. Para ello, se puede añadir un prefijo o un sufijo al nombre del componente. Por ejemplo, header, se puede crear con el prefijo usado para crear el proyecto. Por ejemplo, a01header o headera01. 
- Los nombres de componentes que tienen dos o más palabras se pueden crear separándolas mediante un guión, un guión bajo o usando la notación **camelCase**. Por ejemplo, si se quisieran crear dos cabeceras o más, y a una de ellas se quiere llamar, `Main Header`, se podría crear el componente como:

```htmlmixed
ng g c MainHeader
ng g c mainHeader
ng g c Main_header
ng g c main_header
ng g c main-header
```
Son algunos ejemplos. Da igual. Angular 8 tiene esto muy tipificado. Uses la sintaxis que uses, Angular creará, para el componente, un directorio que se llamará **main-header**, y el componente en sí se llamará **MainHeader**. La única excepción es si unes las dos palabras sin solución de continuidad, así:

`ng g c mainheader`

En ese caso, Angular creará un directorio llamado *mainheader*, y el componente se llamará Mainheader. Obviamente, esto último no es la mejor solución.


**Agregando librerías externas**

Una de las funcionalidades básicas de cualquier aplicación es poder incorporar librerías externas. 
En el ecosistema de Internet existen gran cantidad de librerías que se pueden usar para los trabajos de frontend. Evidentemente Angular 8 no tendría ningún sentido si no pudiera incorporar librerías externas de otros fabricantes.
Angular permite incluir (y usar en la aplicación) cualquier librería CSS o JavaScript del mercado.

Instalaremos **Bootstrap** y, para poder usar el JavaScript que incorpora, instalaremos también **jQuery**. 

Para instalar **jQuery**, desde la terminal de VSC, y dentro del directorio de la aplicación:

`npm install jquery --save`

Si quisiéramos instalarlo como dependencia de desarrollo la instrucción que teclearíamos sería:

`npm install jquery --save-dev`

Sin embargo, dado que se está instalando una librería cuyas funcionalidades deben estar operativas, también, cuando se despliegue la aplicación para el cliente se utilizará la primera opción:

El siguiente paso es instalar Bootstrap. Lo haremos con la siguiente instrucción:

`npm install bootstrap --save`

E fichero package.json ahora ha cambiado, para incluir la referencia a estas dos librerías. Su contenido queda ahora así:

```javascript
{
   "name": "angular01",
   "version": "0.0.0",
   "license": "MIT",
   "scripts": {
     "ng": "ng",
     "start": "ng serve --aot -o",
     "build": "ng build --prod",
     "test": "ng test",
     "lint": "ng lint",
     "e2e": "ng e2e"
   },
   "private": true,
   "dependencies": {
     "@angular/animations": "^5.2.0",
     "@angular/common": "^5.2.0",
     "@angular/compiler": "^5.2.0",
     "@angular/core": "^5.2.0",
     "@angular/forms": "^5.2.0",
     "@angular/http": "^5.2.0",
     "@angular/platform-browser": "^5.2.0",
     "@angular/platform-browser-dynamic": "^5.2.0",
     "@angular/router": "^5.2.0",
     "bootstrap": "^4.1.1",
     "core-js": "^2.4.1",
     "jquery": "^3.3.1",
     "rxjs": "^5.5.6",
     "zone.js": "^0.8.19"
   },
   "devDependencies": {
     "@angular/cli": "~1.7.4",
     "@angular/compiler-cli": "^5.2.0",
     "@angular/language-service": "^5.2.0",
     "@types/jasmine": "~2.8.3",
     "@types/jasminewd2": "~2.0.2",
     "@types/node": "^6.0.108",
     "codelyzer": "^4.0.1",
     "jasmine-core": "~2.8.0",
     "jasmine-spec-reporter": "~4.2.1",
     "karma": "~2.0.0",
     "karma-chrome-launcher": "~2.2.0",
     "karma-coverage-istanbul-reporter": "^1.2.1",
     "karma-jasmine": "~1.1.0",
     "karma-jasmine-html-reporter": "^0.2.2",
     "protractor": "~5.1.2",
     "ts-node": "~4.1.0",
     "tslint": "~5.9.1",
     "typescript": "~2.5.3"
   }
 }
 ```

Ahora hay que informar al CLI dónde están ubicadas, para que pueda hacer uso de ellas.
Las librerías externas se incluyen en la carpeta node_modules, ya que han sido instaladas con npm. No obstante, el CLI, por defecto, no "sabe" donde debe buscarlas. Hay que decírselo en el fichero **angular.json**.
- En primer lugar, hay que añadir una referencia a los estilos CSS de Bootstrap. Para ello, se tiene que modificar la propiedad styles, cuyo aspecto original es el siguiente:

  ```javascript
  "styles": [
    "styles.css"
  ],
  Debe quedar modificada así:
  "styles": [
    "../node_modules/bootstrap/dist/css/bootstrap.min.css",
    "styles.css"
  ],
  ```

En este caso, sólo se han referenciado los estilos básicos de Bootstrap. Como esta librería incluye otros archivos de estilos, tales como temas, si se quieren usar también deben ser referenciados en la propiedad styles.

Para referenciar jQuery, y el JavaScript de Bootstrap se utiliza la propiedad `scripts`, cuyo contenido por defecto es una matriz vacía, así:

    ```javascript
    "scripts": [],

    //se referencian ambos contenidos javaScript, así:
    "scripts": [
      "../node_modules/jquery/dist/jquery.min.js",
      "../node_modules/bootstrap/dist/js/bootstrap.min.js"
    ],
    ```

También se pueden integrar las librerías como
CDN (Content Delivery Network o Red de Entrega de Contenido Estático) en el archivo index.html. Quedaría así:

  ```html
  <!doctype html>
  <html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Angular01</title>
    <base href="/">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
      <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js"></script>
  </head>
  <body>
    <a01-root></a01-root>
  </body>
  </html>
  ```

**Usando las librerías externas**

Para dar estilo a la cabecera de las vistas del ejemplo (el componente HeaderComponent creado anteriormente), se usará la clase Jumbotron de Bootstrap (clase específica que permite crear un área con todo el ancho de la página, para el contenido de la cabecera;  https://getbootstrap.com/docs/4.1/examples/jumbotron/): 

- En primer lugar, se edita el archivo principal de estilos del proyecto Angular (src/styles.css) para dejarlo vacío, como se crea por defecto. 
- Se modifica el código de header.component.css, simplificándolo mucho. Unicamente se establece un color azul para el fondo de la cabecera (para sustituir el gris pálido que tiene el Jumbotron por defecto), y se mantiene el color rojo oscuro del rótulo h1, así:

```css
header {
   background-color: #00b4b3;
 }

  h1 {
   color: #840101;
 }
```

- Se edita el archivo header.component.html añadiéndole, a la etiqueta <header> la clase jumbotron, así:

```html
<header class="jumbotron">
   <h1>Cabecera de la aplicación</h1>
 </header>
```

- Se modifica el archivo app.component.html y se añade la clase container-fluid de Bootstrap, al rótulo h1:

```html
<a01-header></a01-header>
  <h1 class="container-fluid">
   Página principal de la aplicación
 </h1>
  <router-outlet></router-outlet>
```

Y ya está. Se inicializa el servidor (npm start)y se carga la página con el estilo Jumbotron de Bootstrap en la cabecera, y la tipografía también es la que incluye Bootstrap, en lugar de la que emplea el navegador por defecto. 
