# Introducción a los formularios

Vamos a aprender a crear y usar formularios en nuestras aplicaciones Angular. Después de todo, ¿qué aplicación web no incluye formularios? Aunque sólo sea un mero formulario de contacto, para que nuestro visitantes se pongan en contacto con nosotros, al menos tendremos ése. Si la aplicación es un poco compleja o aspiracional, seguro que necesitaremos más.
La implementación de formularios en vistas de una aplicación Angular puede parecer un poco más compleja que la inserción de un formulario en bruto en HTML (y lo es). A cambio, nos permite unas prestaciones muy interesantes, a nivel de validación de datos, comunicaciones en tiempo real entre la vista y la lógica del componente, etc.
Empezaremos viendo los Formularios desde templates (Angular Template Driven Forms) 

## CREANDO LA APLICACIÓN

Vamos a empezar creando una aplicación nueva

`ng new angular-myforms -p amf --routing true`

### LA ESTRUCTURA BASE DE LA APLICACIÓN

Crearemos un módulo para almacenar los formularios que vayamos creando a lo largo de este y los siguientes artículos. Lo llamaremos MyForms:
`ng g m MyForms --routing`
Lo creamos con su propio sistema de enrutamiento, lo que nos permitirá cargarlo de forma perezosa.

También vamos a crear un módulo para elementos comunes, o generales, que no tengan, a priori, cabida "lógica" en otra parte de la aplicación. Lo llamaremos commons (como ya hicimos en el ejecicio de la sección anterior). Esta vez lo crearemos sin enrutador propio. Los componentes de este módulo deberán cargarse de forma directa.
`ng g m commons`

   - Dentro de commons crearemos un componente para la barra de navegación (`navbar`), otro para la cabecera (`header`) y un componente para la vista principal de la aplicación (`home`). También crearemos un componente para la vista derivada de los errores de tipo 404, al que llamaremos `notFound`. Los cuatro los haremos exportables.
      ```ng g c commons/navbar --export
      ng g c commons/header --export
      ng g c commons/home --export
      ng g c commons/notFound --export
      ```
Además (y esto recuérdalo porque es de una importancia extrema),**en la lógica del módulo debemos importar el RouterModule**, que "vive" en @angular/router. No importa que hayamos creado nuestro módulo CommonsModule sin enrutamiento interno. Debemos importar RouterModule por una razón. Entre los componentes de este módulo va la barra de navegación (NavbarComponent). Como ya sabemos, los enlaces no se construyen con la propiedad href de HTML, sino con la propiedad routerLink de Angular. Pues bien. Si no importamos el RouterModule en la lógica del módulo, la propiedad routerLink no funcionará. En concreto, el archivo commons.module.ts debe quedarnos así:
```ts
import { NgModule } from '@angular/core';
 import { CommonModule } from '@angular/common';
 import { NavbarComponent } from './navbar/navbar.component';
 import { HeaderComponent } from './header/header.component';
 import { HomeComponent } from './home/home.component';
 import { RouterModule } from '@angular/router';
  @NgModule({
   imports: [
     CommonModule,
     RouterModule
   ],
   declarations: [NavbarComponent, HeaderComponent, HomeComponent],
   exports: [NavbarComponent, HeaderComponent, HomeComponent]
 })
 export class CommonsModule { }
 ```

### IMPORTANDO CommonsModule EN AppModule
Para dejar preparadas todas las importaciones, y dado que CommonsModule tiene componentes que deberán ser visibles desde AppModule, es necesario importar el primero en el segundo. Además, ya que vamos a tocar app.module.ts, importaremos la notación en español para números, fechas, etc. Nos queda así:

```ts
import { BrowserModule } from '@angular/platform-browser';
 import { NgModule } from '@angular/core';
 import { AppRoutingModule } from './app-routing.module';
  import { registerLocaleData } from '@angular/common';
 import localeEs from '@angular/common/locales/es';
 registerLocaleData(localeEs);
  import { AppComponent } from './app.component';
 import { CommonsModule } from './commons/commons.module';
  @NgModule({
   declarations: [
     AppComponent
   ],
   imports: [
     BrowserModule,
     AppRoutingModule,
     CommonsModule
   ],
   providers: [],
   bootstrap: [AppComponent]
 })
 export class AppModule { }
 ```

Observa que lo importamos en las líneas de la 5 a la7, y en la 10, y añadimos el CommonsModule a la propiedad declarations del decorador, en la línea 19. Si estás usando VSC correctamente configurado, con que lo añadas a declarations ya te hace la importación automáticamente.

### EL ENRUTADOR RAÍZ

Este es otro elemento que tenemos que modificar. Tenemos el componente HomeComponent, que tendrá la vista de inicio y se cargará en directo, y el módulo MyFormsModule, que hemos creado con su propio enrutador, y se cargará en diferido (por carga perezosa). Para terminar, el NotfoundComponent se cargará cuando se teclee una ruta que no se encuentre en la matriz Routes. En concreto, app-routing-module.ts nos queda así:
```ts
import { NgModule } from '@angular/core';
 import { Routes, RouterModule } from '@angular/router';
 import { HomeComponent } from './commons/home/home.component';
 import { NotFoundComponent } from './commons/not-found/not-found.component';
  const routes: Routes = [
   {
     path: '',
     component: HomeComponent
   },
   {
     path: 'formularios',
     loadChildren: './my-forms/my-forms.module#MyFormsModule'
   },
   {
     path: '**',
     component: NotFoundComponent
   }
 ];
  @NgModule({
   imports: [RouterModule.forRoot(routes)],
   exports: [RouterModule]
 })
 export class AppRoutingModule { }
```

### EL ENRUTAMIENTO DE MyFormsModule
Para poder crear una estructura mínima, vamos a generar un componente, llamado Form01Component, en el módulo MyFormsModule, así:

`ng g c MyForms/form01`

Será el que empleemos en el primer formulario de ejemplo que crearemos en esta aplicación aunque, por ahora, lo vamos a crear "en bruto", es decir, sin contenido específico alguno.
Y, como es lógico, vamos a iniciar el enrutamiento interno del módulo (my-forms-routing.module.ts), sólo para "irlo dejando preparado":

```ts
import { NgModule } from '@angular/core';
 import { Routes, RouterModule } from '@angular/router';
 import { Form01Component } from './form01/form01.component';
  const routes: Routes = [
   {
     path: 'f01',
     component: Form01Component
   }
 ];
  @NgModule({
   imports: [RouterModule.forChild(routes)],
   exports: [RouterModule]
 })
 export class MyFormsRoutingModule { }
```

### INSTALANDO LIBRERÍAS EXTERNAS
Instalaremos jQuery y Bootstrap, como ya sabemos:
  ```
  npm install --save jquery
  npm install --save bootstrap
  ```

Ahora vamos a instalar la librería de JavaScript moment.js, que usaremos en algunos formularios:

`npm install --save moment`

En angular.json modificaremos las claves styles y scripts para que queden así:
```ts
"styles": [
   "../node_modules/bootstrap/dist/css/bootstrap.min.css",
   "styles.css"
 ],
 "scripts": [
   "../node_modules/jquery/dist/jquery.js",
   "../node_modules/bootstrap/dist/js/bootstrap.min.js",
   "../node_modules/moment/min/moment.min.js"
 ],
 ```

Observa que los CSS de bootstrap los incluímos antes de los estilos de la aplicación. De este modo, cuando lo deseemos, podremos sobrescribir las clases originales de bootstrap, para modificar el aspecto de nuestra web.

### LOS HTML

Llegados a este punto, vamos a modificar los HTML de los componentes para poner un rótulo relevante de lo que hacen, o la mecánica básica necesaria.
HomeComponent Y NotFoundComponent
Estos son los más simples. Ya los adornaremos si llega el caso pero, por ahora, con lo mínimo ya basta:

  ```html
  <!-- home.component.html -->

  <div class='container'>
    <h1>Vista de inicio</h1>
  </div>
  <!-- not-found.component.html -->
  <div class='container'>
    <h1>Recurso no encontrado.</h1>
    <h3>Revisa la URL</h3>
  </div>
  ```

**HeaderComponent**

Como ya tenemos bootstrap, a esta vista vamos a darle un toque un "pelín" más visual:
```html
<!-- Cabecera global de la página -->
 <div class='container-fluid jumbotron'>
   <h1>Cabecera global del sitio</h1>
 </div>
```
**NavbarComponent**

Esta vista ya tiene un poco más de materia, ya que vamos a crear una barra de navegación de bootstrap.
<!-- navbar.component.html -->
 <nav class="navbar navbar-default navbar-fixed-top navbar-inverse navbar-fixed-top">
     <div class="container-fluid">
       <!-- Brand and toggle get grouped for better mobile display -->


<nav class="navbar navbar-expand-lg navbar-light bg-light">
  <a class="navbar-brand" href="#">Navbar</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse" id="navbarNavDropdown">
    <ul class="navbar-nav">
      <li class="nav-item active">
        <a class="nav-link" routerLink='home'>Home <span class="sr-only">(current)</span></a>
      </li>

   
   
**AppComponent**

Aquí tenemos que eliminar el código que aparece por defecto al crear la aplicación, e insertar los elementos comunes a todo el sitio, así:

<!-- app.component.html -->
 <amf-navbar></amf-navbar>
 <amf-header></amf-header>
  <router-outlet></router-outlet>

### LOS ESTILOS GENERALES DEL SITIO
Aprovechando que los estilos generales del sitio (styles.css) los hemos incluido después de los de los de bootstrap en angular.json, vamos a retocarlos un poco, para que nos quede esto algo más aparente:
```cs
body{
   width: 100%;
   position: absolute;
   z-index: 2;
 }
 .jumbotron {
   position: fixed;
   width: 100%;
   top: 51px;
   z-index: 2
 }
  .container {
   position: relative;
   top: 246px;
   z-index: 1;
 }
 ```

ATENCIÓN: Observa que, como hemos dicho, estamos sobrescribiendo, parcialmente, algunas clases de bootstrap. Esto es muy habitual en desarrollos web. Sea cual sea el framework CSS que emplees (bootstrap, materialize, milligram, o el que sea), será muy fácil que, por tu diseño, tengas que sobrescribir algunas de las clases tipificadas por el framework. Por esta razón, si te fijas en el fichero angular.json verás que cargamos es CSS de bootstrap antes de los estilos globales de la aplicación. Si lo hiciéramos al revés, no podríamos sobrescribir las clases. En la aplicación anterior no lo hicimos así, pero aquí ya vamos a empezar a cuidar más esos detalles.


## Primer formulario en Angular

Empezaremos con un formulario muy simple, pero que nos permitirá introducir algunos conceptos básicos. Veremos como preparamos un formulario en la vista, como mostramos algunos datos predefinidos en campos de dicho formulario y, lo más importante, empezaremos a ver como comunicamos el contenido del formulario con la lógica del componente. Esta comunicación puede ser en dos sentidos: pasando datos de la lógica a la vista, y/o de la vista a la lógica.
Aquí sentaremos las bases de como debe crearse un formulario en un componente Angular. Será muy simple, pero nos iniciará para seguir aprendiendo y profundizando.

### EL FORMULARIO EN HTML

Vamos a empezar por el principio. Al igual que cuando hacemos una web "picando" código directamente (sin Angular), los formularios se construyen con HTML. Dentro del contexto Angular, se siguen construyendo en HTML, aunque con más prestaciones que los formularios clásicos. Realmente, los campos siguen siendo los mismos, aunque algunos conceptos y formas de "hacer las cosas" cambian de forma significativa. Vamos a empezar por ver como creamos un formulario muy sencillo, y a extraer conocimientos concretos de él. Para ello nos vamos al componente Form01Component, que hemos creado para esto, e incluimos el formulario en el form01.component.html:

```html
<div class='container'>
   <h1>Primer formulario</h1>
   <form>
     <label>Nombre de usuario:
       <input type='text' class='form-control' #username>
     </label>
     <br>
     <label>Contraseña:
       <input type='password' class='form-control' #usernamePass>
     </label>
     <br>
     <input type='button' class='btn btn-primary' #sendButton value='Aceptar'>
   </form>
 </div>
 ```

Si pruebas tu aplicación y accedes al primer formulario (que es la única opción que, por ahora, tenemos en el submenú de formularios), verás que se te carga el formulario en la página. Aún no hace nada, pero ahí está el formulario que hemos programado en HTML. Veamos las primeras peculiaridades.
Lo primero que tal vez te llame la atención está en la línea 3. Hemos abierto la etiqueta form, y no le hemos especificado ni método, ni destino, ni nada. Bueno. De momento, no lo necesitamos y, en muchos casos, no llegaremos a necesitarlo nunca (en otros, tal vez sí, pero serán los menos). El porqué de no necesitar definir estas propiedades tiene mucho que ver, evidentemente, con la forma en que se procesan los formularios en Angular. Lo empezaremos a entender en este artículo, y lo veremos muy claramente cuando aprendamos a conectar nuestra aplicación con servidores que deban recibir los datos del formulario (para esto último aún nos falta, no te agobies).
Lo siguiente que debería llamarnos la atención de alguna manera es la forma de definir los elementos del formulario. Tenemos dos campos donde el usuario puede teclear (uno de tipo text y otro de tipo password), y un botón, definidos, respectivamente en las líneas 5, 9 y 12. Observa que los elementos no llevan atributo id y, en su lugar, tienen el identificativo precedido del signo #. Dado que, en HTML "normal" el atributo id es para manipular el campo desde JavaScript, y que en el contexto Angular esta manipulación la haremos desde el archivo TypeScript del componente, usamos la notación de Angular para identificar los elementos. Esta notación no es nueva. Cuando hablamos de directivas ya la mencionamos para identificar los elementos ng-template (puedes repasarlo en este artículo). Aquí, la usamos para referenciar los campos desde el TypeScript.

### CONECTANDO DE LA LÓGICA A LA VISTA

Vamos a ver como podemos conectar la vista con la logica, para pasar datos de la lógica a la vista. Esto se hace mediante la técnica de binding de propiedades, que ya conocemos de un artículo anterior. Observa una modificación en el HTML:

```html
<div class='container'>
   <h1>Primer formulario</h1>
   <form>
     <label>Nombre de usuario:
       <input type='text' class='form-control' #usernameField [placeholder]='placeholders.username'>
     </label>
     <br>
     <label>Contraseña:
       <input type='password' class='form-control' #usernamePass [placeholder]='placeholders.userpass'>
     </label>
     <br>
     <input type='button' class='btn btn-primary' #sendButton value='Aceptar'>
   </form>
 </div>
 ```

Como ves, a los campos de texto les hemos añadido el atributo [placeholder] (así, entre cochetes, lo que indica que espera recibir "algo" de la lógica e interpretarlo). En la lógica del componente (form01.component.ts) debemos definir los placeholders que vamos a pasarle a los campos, así:

```ts
import { Component, OnInit } from '@angular/core';
  @Component({
   selector: 'amf-form01',
   templateUrl: './form01.component.html',
   styleUrls: ['./form01.component.css']
 })
 export class Form01Component implements OnInit {
    placeholders = {
     'username': 'Teclea tu nombre de usuario',
     'userpass': 'Teclea tu contraseña'
   };
    constructor() { }
    ngOnInit() {
   }
 }
```

Observa en las líneas resaltadas como hemos definido un objeto llamado placeholders, con dos propiedades: una llamada username y otra llamada userpass, que son las que incluimos mediante binding en la vista. Graba los cambios en ambos elementos y verás el resultado en tu navegador.

### CONECTANDO DE LA VISTA A LA LÓGICA, Y VUELTA
Así como para pasar datos de la lógica a la vista usamos el binding de propiedades, para desencadenar un proceso en la lógica desde la vista usamos el binding de eventos, que conocimos en este artículo. En este ejemplo, vamos a hacer que, al pulsar el botón, el contenido de los campos se muestre como un texto en la vista, por lo que también tendremos que volver a usar el binding de propiedades. De esta forma, veremos una comunicación total entre la vista y la lógica. Esta vez vamos a empezar por ver la lógica, en 
form01.component.ts:
```ts
import { Component, OnInit } from '@angular/core';
  @Component({
   selector: 'amf-form01',
   templateUrl: './form01.component.html',
   styleUrls: ['./form01.component.css']
 })
 export class Form01Component implements OnInit {
    nombreRecibido = '';
   passRecibida = '';
    placeholders = {
     'username': 'Teclea tu nombre de usuario',
     'userpass': 'Teclea tu contraseña'
   };
    constructor() { }
    recibirDatos(nombre, pass) {
     this.nombreRecibido = nombre.value;
     this.passRecibida = pass.value;
   }
    ngOnInit() {
   }
 }
 ```

Observa que empezamos declarando dos variables, que luego recibirán los datos tecleados en el formulario. Inicialmente las declaramos vacías, y públicas para que sean accesibles desde la vista. Lo hacemos en las líneas 10 y 11.

Lo siguiente que vemos es en las líneas de la 20 a la 23. Se define una función, que por estar dentro de la clase Form01Component es un método de esta clase. Lo que hace es recibir los campos del formulario y asignar sus valores a las variables que habíamos declarado previamente. El método se llama recibirDatos.
Sin embargo, aún nos faltan dos cosas: un desencadenante para que se ejecute el método, y una forma de visualizar los datos en la vista. Ambas cosas se montan, precisamente, en dicha vista (form01.component.html):

```html
<div class='container'>
   <h1>Primer formulario</h1>
   <form>
     <label>Nombre de usuario:
       <input type='text' class='form-control' #usernameField [placeholder]='placeholders.username'>
     </label>
     <br>
     <label>Contraseña:
       <input type='password' class='form-control' #usernamePass [placeholder]='placeholders.userpass'>
     </label>
     <br>
     <input type='button' (click)='recibirDatos(usernameField, usernamePass);' class='btn btn-primary' #sendButton value='Aceptar'>
   </form>
   <div class="row"><br></div>
   <ng-container *ngIf="(nombreRecibido > '' && passRecibida > ''); else faltanDatos">
     El nombre de usuario es: <strong>{{nombreRecibido}}</strong>
     <br>
     La clave es: <strong>{{passRecibida}}</strong>
   </ng-container>
   <ng-template #faltanDatos>
     Falta el nombre de usuario, la clave o ambos.
   </ng-template>
 </div>
 ```

En primer lugar, observa la línea 15. Hacemos que el botón, al ser pulsado (evento click) desencadene el método recibirDatos, pasándole los dos campos del formulario. Observa que le pasa los campos identificándolos por el id que recibieron con el signo #. Esta forma de trabajar no pasa el valor del campo, si no todo el campo como un objeto. Por esta razón en el método se extrae la propiedad value, que es lo que nos interesa. Para desecadenar el método usamos la técnica de binding de eventos.
En las líneas 20 a 22 comprobamos si ambas propiedades tienen un valor mayor que una cadena vacía (que es el valor que recibían por defecto). Si es el caso, mostramos los valores en la vista. En caso contrario mostramos un mensaje indicando que falta uno o los dos datos. 

Y ya lo tenemos. Ahora, cuando cargues esta vista, verás, inicialmente, el mensaje que te indica que faltan datos. Cumplimenta los dos datos del formulario y pulsa el botón, y verás que el mensaje cambia, mostrándote los datos que hayas tecleado.

## Segundo formulario: Uso de clases

Una vez que ya tenemos decidida la estructura de la ficha de los usuarios, tenemos que considerar que el usuario será un objeto, perteneciente a una clase. Por lo tanto, debemos crear una clase para el objeto.

### MONTANDO UNA CLASE

Cuando vamos a usar clases en nuestra aplicación es razonable pensar que tales clases deberán estar disponibles no sólo desde un componente específico, sino desde varios componentes (tal vez situados, incluso, en diversos módulos). Por lo tanto, la ubicación de las clases debería ser alcanzable fácilmente desde cualquier punto de la aplicación. Lo habitual es crear una carpeta genérica para albergar las clases, dentro de la raíz del proyecto, es decir, src/app/. En esa ubicación crearemos un directorio al que podemos llamar, por ejemplo, `classes`, o darle un nombre usando el prefijo de la aplicación. Yo he optado por esta última opción, y lo he llamado `amf-classes`.
A continuación, dentro de ese directorio, vamos a crear una clase para los objetos que representen a los usuarios. La vamos a llamar, por seguir con la tónica de usar el prefijo de la aplicación, AmfUser. En la terminal de VSC tecleamos lo siguiente:

`ng g class amf-classes/AmfUser`

Tras unos segundos, la terminal nos responde:
create src/app/amf-classes/amf-user.ts (25 bytes)
Abrimos el archivo que se acaba de crear y vemos la estructura básica, vacía, de la clase:
```ts
export class AmfUser {
 }
 ```

Ahora tenemos que declarar las propiedades y métodos que necesitemos. De momento, crearemos los que necesitemos a priori, y, si luego nos hacen falta más, ya los iremos añadiendo. Así pues, nuestra clase queda, de momento, así:

```ts
export class AmfUser {
   private id: string;
   private username: string;
   private password: string;
    constructor() {
     this.id = this.uniqueId();
     this.username = '';
     this.password = '';
   }
    /**
    * Setters y Getters de la clase
    */
   public setUsername(username) {
     this.username = username;
   }
   public setPassword(password) {
     this.password = password;
   }
    public getId() {
     return this.id;
   }
   public getUsername() {
     return this.username;
   }
   public getPassword() {
     return this.password;
   }
    private uniqueId() {
     const thisMS: number = Date.now();
     const shake = Math.random();
     let unique: string = Math.pow(thisMS, shake).toString();
     unique = unique.toString().replace('.', thisMS.toString());
     return unique;
   }
 }
```
Vamos a ver lo que hemos incluido. Empezamos por las líneas 2, 3 y 4. En ellas se definen las tres propiedades que, en principio, van a tener los objetos de esta clase (id, username y password). Las variables las declaramos privadas (private) para que no sean accesibles directamente desde fuera de la clase, sino que haya que llegar a ellas a través de métodos `setter` y `getter`. Esto no es nada nuevo. La encapsulación es una buena práctica de programación en cualquier entorno o lenguaje, como ya sabes.
En las líneas de la 6 a la 10 se declara el constructor. Como sabes, este método se ejecuta, de forma automática, cada vez que se crea un nuevo objeto. En esta clase, el constructor es muy simple. Tan sólo le asigna un identificador único al usuario. Esto es porque el identificador debe asignarse automáticamente, de forma transparente al usuario. Ocurre un poco como cuando usamos bases de datos relacionales, del tipo de MySQL, y declaramos un campo como clave primaria autoincrementable. Sin embargo, en TypeScript no contamos con una función específica para generar un identificador único, al estilo de la combinación de uniqueid y mda5 en PHP, por ejemplo. Por esa razón, hemos tenido que crear una función específica para este fin. Lo hemos hecho con el método `uniqueId()`, declarado entre las líneas 32 y 38. No vamos a entrar en detalles, pero jugamos con una combinación de `Date.now()` y `Math.random()`, para generar un identificador que podemos estar razonablemente seguros de que será único. En principio, podría parecer que nos basta con el uso de `Date.now()`, porque nos devuelve un valor distinto cada milisegundo. Sin embargo, con la velocidad de proceso de los ordenadores actuales, y si nuestra aplicación tuviera múltiples concurrencias simultáneas, podría darse el caso de que dos o más usuarios compartieran identificador. Con este método estamos "casi" seguros de que eso no va a suceder. Y por "casi" entendemos "todo lo seguros que se puede estar". Sólo comentar que este método lo hemos declarado como privado, porque sólo vamos a necesitar acceder a él desde dentro de la clase (en concreto, dentro del constructor). Desde fuera no nos va a hacer falta.
Por lo demás, el constructor sólo asigna cadenas vacías a las otras propiedades. Esto también es una buena práctica de programación. Cuando se crea un objeto, es bueno asignarle valores por defecto a las propiedades, para que no queden como undefined. De esta forma, tipificamos la estructura del nuevo objeto.
El resto de la clase son los métodos setter y getter que comentábamos más arriba.

### EL COMPONENTE PARA EL FORMULARIO

Vamos a crear un formulario en un componente nuevo, para conservar el del artículo anterior, a fin de poder ir comparando los ejercicios que hacemos. Para ello, empezamos generando un nuevo componente, dentro del módulo `MyFormsModule`, así:

`ng g c my-forms/form02`

La lógica del módulo (my-forms.module.ts) se ha modificado para reconocer el nuevo componente, así:
```ts
import { NgModule } from '@angular/core';
 import { CommonModule } from '@angular/common';
  import { MyFormsRoutingModule } from './my-forms-routing.module';
 import { Form01Component } from './form01/form01.component';
 import { Form02Component } from './form02/form02.component';
   @NgModule({
   imports: [
     CommonModule,
     MyFormsRoutingModule
   ],
   declarations: [Form01Component, Form02Component],
   exports: []
 })
 export class MyFormsModule { }
 ```

Ahora están declarados los dos componentes (el que teníamos de antes y el que acabamos de crear).
El siguiente paso de la preparación es importar la clase que hemos creado en la lógica del componente donde la vamos a usar (form02.component.ts), así:

```ts
import { Component, OnInit } from '@angular/core';
 import { AmfUser } from '../../amf-classes/amf-user';
  @Component({
   selector: 'amf-form02',
   templateUrl: './form02.component.html',
   styleUrls: ['./form02.component.css']
 })
 export class Form02Component implements OnInit {
    constructor() { }
    ngOnInit() {
   }
 }
 ```

En la línea resaltada, vemos como hacemos esto.
Vamos a hacer que el nuevo componente sea accesible desde el menú. Todavía no lo tenemos montado, pero no importa. Lo dejamos accesible, y luego ya lo montaremos. En la barra de navegación (commons/navbar.component.html) tenemos que añadirle un enlace en el submenú de formularios, así:

```html
<!-- navbar.component.html -->
 <nav class="navbar navbar-default navbar-fixed-top navbar-inverse navbar-fixed-top">
     <div class="container-fluid">
       <!-- Brand and toggle get grouped for better mobile display -->
       <div class="navbar-header">
         <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1"
           aria-expanded="false">
           <span class="sr-only">Alternar navegación</span>
           <span class="icon-bar"></span>
           <span class="icon-bar"></span>
           <span class="icon-bar"></span>
         </button>
         <a class="navbar-brand" routerLink='' style='cursor:pointer;'>MyForms</a>
       </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
       <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
         <ul class="nav navbar-nav">
           <li>
             <a routerLink='' style='cursor:pointer;'>Inicio</a>
           </li>
           <li class="dropdown">
             <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Formularios
               <span class="caret"></span>
             </a>
             <ul class="dropdown-menu">
               <li>
                 <a routerLink='formularios/f01'>Formulario 01</a>
               </li>
                <li>
                 <a routerLink='formularios/f02'>Formulario 02</a>
               </li>
              </ul>
           </li>
         </ul>
       </div>
       <!-- /.navbar-collapse -->
     </div>
     <!-- /.container-fluid -->
   </nav>
   ```

Observa el nuevo enlace en las líneas resaltadas. No tiene nada de especial.
Cómo el módulo de los formularios se carga en diferido, debemos añadir la ruta en el enrutador interno de dicho módulo (my-forms-routing.module.ts), así:
```ts
import { NgModule } from '@angular/core';
 import { Routes, RouterModule } from '@angular/router';
 import { Form01Component } from './form01/form01.component';
 import { Form02Component } from './form02/form02.component';
  const routes: Routes = [
   {
     path: 'f01',
     component: Form01Component
   },
   {
     path: 'f02',
     component: Form02Component
   }
 ];
  @NgModule({
   imports: [RouterModule.forChild(routes)],
   exports: [RouterModule]
 })
 export class MyFormsRoutingModule { }
 ```

### MONTAR EL FORMULARIO

Ahora que ya tenemos la clase para manejar los objetos que representarán a los usuarios, vamos a replantear la lógica del componente del formulario en form02.component.ts:
```ts
import { Component, OnInit } from '@angular/core';
 import { AmfUser } from '../../amf-classes/amf-user';
  @Component({
   selector: 'amf-form02',
   templateUrl: './form02.component.html',
   styleUrls: ['./form02.component.css']
 })
 export class Form02Component implements OnInit {
   public user: AmfUser = new AmfUser();
   public placeholders = {
     username: 'Teclea tu nombre de usuario',
     userpass: 'Teclea tu contraseña'
   };
    constructor() {}
    createUser(myForm) {
     this.user.setUsername(myForm[0].value);
     this.user.setPassword(myForm[1].value);
   }
    ngOnInit() {}
 }
 ```
En la línea 2 ves como se importa la clase AmfUser, que hemos creado anteriormente. Es necesario importarla, para poder usarla en el componente.
En la línea 10, se crea un objeto de la clase AmfUser. Como sabes, por el constructor de la clase, a este objeto ya se le asigna un identificador (propiedad id) único.
Luego encontramos el método createUser(), entre las líneas 18 y 21. Es similar al del ejemplo anterior, pero hay algunas leves mejoras. En primer lugar, ya no recibe dos parámetros, si no sólo uno. Este es el formulario en conjunto, en lugar de los campos individuales. Dentro del método se accede a cada campo como un elemento indexado, de forma que ya sabemos que el formulario se recibe como un arreglo. Así, el primer campo (con el índice 0) contiene el primer campo del formulario (el del nombre de usuario) y el segundo (con el índice 1) contiene el segundo campo del formulario (el de la contraseña). La propiedad value de estos campos es asignada a las correspondientes propiedades del objeto mediante el método setter empleado para cada una.
Esto implica también algunos retoques en la vista (form02.component.html):

```html
<div class='container'>
   <h1>Segundo formulario</h1>
   <form #newUserForm>
     <label>Nombre de usuario:
       <input type='text' class='form-control' #usernameField [placeholder]='placeholders.username' [value]='user.getUsername()'>
     </label>
     <br>
     <label>Contraseña:
       <input type='password' class='form-control' #userPass [placeholder]='placeholders.userpass' [value]='user.getPassword()'>
     </label>
     <br>
     <input type='button' (click)='createUser(newUserForm)' class='btn btn-primary' #sendButton value='Aceptar'>
   </form>
   <div class="row">
     <br>
   </div>
   <ng-container *ngIf="(user.getUsername() > '' && user.getPassword() > ''); else faltanDatos">
     El id de usuario es:
     <strong>{{user.getId()}}</strong>
     <br>
     El nombre de usuario es:
     <strong>{{user.getUsername()}}</strong>
     <br>
     La clave es:
     <strong>{{user.getPassword()}}</strong>
   </ng-container>
   <ng-template #faltanDatos>
     Falta el nombre de usuario, la clave o ambos.
   </ng-template>
 </div>
 ```

En primer lugar, observa la línea 3, donde se abre el formulario. Esta vez, le hemos asignado un identificador, al estilo de Angular, es decir, precedido con el signo #. Luego usaremos ese identificador para enviar el formulario.
En las líneas 5 y 9 vemos que a los campos les hemos dado el valor de las propiedades username y password del objeto `AmfUser`. Como el objeto está recién creado, estas son cadenas vacías, por lo que en los campos se muestran los placeholders. Sin embargo, lo hemos hecho así para que veas la sintaxis. Como las propiedades las definimos como privadas en la clase AmfUser, no las referenciamos directamente, sino a través del método getter correspondiente. Este uso de métodos getter los ves también en el condicional de la línea 17, y en la obtención de la propiedad id del usuario en la línea 19.
Ahora observa la línea 12, donde hacemos el binding de eventos. Como ves, esta vez sólo pasamos un argumento, que es el identificador que le asignamos al formulario. Por lo tanto, como respuesta a la pulsación del botón, se pasa a la lógica el formulario como un todo. Como ya sabemos, es dentro del TypeScript donde se extraen los datos elemento a elemento.

## Formularios complejos

Vamos a empezar a darle a nuestro formulario mayor complejidad, añadiendo más tipos de campos y funcionalidades. Veremos como conectar la vista con el modelo de datos de una forma más eficiente (aunque también, inherentemente, más compleja) y como optimizar la gestión general del componente.
En definitiva, se trata de poder diseñar un formulario que satisfaga todas las necesidades que podamos tener para mejorar la experiencia del usuario. Al mismo tiempo, debe poder cumplir especificaciones operativas, e integrar los datos con el objeto al que van detinados.
Lo que vamos a ver en este artículo optimiza mucho la creación de formularios, mediante el uso de directivas propias de Angular. Al usarlas, optimizamos código y aligeramos carga de trabajo.

### LO QUE VAMOS A HACER

Montaremos un formulario complejo que:
- Tenga datos de distintos tipos.
- Sea configurable por TypeScript.
- Actualice los datos del modelo en tiempo real, según el usuario los actualice en la vista.
- Exista un binding bidireccional entre la vista y el modelo, mediante el doble binding.
- Finalmente, almacene los datos en un objeto que luego, en una aplicación real, sería enviado al servidor.
El aspecto del formulario que queremos crear es el que vemos a continación:

![](https://imgur.com/yxLEA7p.png) 

Cómo ves, tenemos campos de distintos tipos, y un botón que, por defecto, aparece inhabilitado. Cuando todos los campos estén cumplimentados se habilitará para ser pulsado. Esto nos muestra ya una especie de tosca prevalidación. Más adelante hablaremos sobre validación de formularios. De momento, vamos a aprender a crearlo.

### PREPARANDO EL TERRENO

Utilizaremos la directiva de Angular llamada `ngModel`. Antes de emplearla debemos saber que, en cualquier módulo en el que uno de sus componentes vaya a emplear ngModel debemos importar el módulo `FormsModule` (propio de Angular), en nuestro propio módulo. Lo vamos a 
importar en my-forms.module.ts, así:

```ts

import { NgModule } from '@angular/core';
 import { CommonModule } from '@angular/common';
 import { FormsModule } from '@angular/forms';
  import { MyFormsRoutingModule } from './my-forms-routing.module';
 import { Form01Component } from './form01/form01.component';
 import { Form02Component } from './form02/form02.component';
 import { Form03Component } from './form03/form03.component';
  @NgModule({
   imports: [
     CommonModule,
     FormsModule,
     MyFormsRoutingModule
   ],
   declarations: [Form01Component, Form02Component, Form03Component],
   exports: []
 })
 export class MyFormsModule { }
 ```

En la línea 3 vemos como lo importamos desde @angular/forms y en la línea 13 vemos como lo añadimos a la clave imports del decorador de nuestro módulo.
Lo siguiente que tenemos que hacer es crear una clase para almacenar los objetos que representen a los usuarios. Ya en el artículo anterior hicimos esto, con muy pocos datos. Esta vez nuestra clase va a definir unos objetos con más propiedades. En la terminal de VSC tecleamos:

`ng g class amf-classes/AmfFullUser`

Con esto se creará el archivo amf-clases/`amf-full-user.ts`, que modificaremos para dejarlo así:
```ts
export class AmfFullUser {
   private id: string;
   private realname: string;
   private username: string;
   private password: string;
   private singingUpDate: string;
   private email: string;
   private continent: string;
   private gender: string;
   private upTo18: boolean;
    constructor() {
     this.id = this.uniqueId();
     this.realname = '';
     this.username = '';
     this.password = '';
     this.singingUpDate = this.getActualDate();
     this.email = '';
     this.continent = '';
     this.gender = '';
     this.upTo18 = true;
   }
    /**
   * Setters de la clase
   */
   public setRealname(realname) {
     this.realname = realname;
   }
   public setUsername(username) {
     this.username = username;
   }
   public setPassword(password) {
     this.password = password;
   }
   public setEmail(email) {
     this.email = email;
   }
   public setContinent(continent) {
     this.continent = continent;
   }
   public setGender(gender) {
     this.gender = gender;
   }
   public setUpTo18(upTo18) {
     this.upTo18 = upTo18;
   }
    /**
    * Getters de la clase
    */
   public getId() {
     return this.id;
   }
   public getRealname() {
     return this.realname;
   }
   public getUsername() {
     return this.username;
   }
   public getPassword() {
     return this.password;
   }
   public getSingingUpDate() {
     return this.singingUpDate;
   }
   public getEmail() {
     return this.email;
   }
   public getContinent() {
     return this.continent;
   }
   public getGender() {
     return this.gender;
   }
   public getUpTo18() {
     return this.upTo18;
   }
    /**
    * Generador de id único
    */
   private uniqueId() {
     const thisMS: number = Date.now();
     const shake = Math.random();
     let unique: string = Math.pow(thisMS, shake).toString();
     unique = unique.toString().replace('.', thisMS.toString());
     return unique;
   }
    /**
    * Obtiene la fecha actual
    */
   private getActualDate(): string {
     const actualDate = new Date();
     let actualDay = actualDate.getDate().toString();
     if (actualDay.length < 2) { actualDay = '0' + actualDay; }
     let actualMonth = actualDate.getMonth().toString();
     if (actualMonth.length < 2) { actualMonth = '0' + actualMonth; }
     const actualYear = actualDate.getFullYear().toString();
     const finalDate = actualDay + '-' + actualMonth + '-' + actualYear;
     return finalDate;
   }
 }
 ```
 En las líneas de la 2 a la 10 vemos que declaramos las propiedades del objeto. Como ya es habitual, las encapsulamos declarándolas como privadas. Accederemos a ellas a través de los métodos setter y getter que declaramos en las líneas de la 24 a la 78. El constructor crea la estructura básica de un objeto, rellenando el identificador con el método uniqueId, y la fecha de creación con el método getActualDate, ambos definidos en la propia clase.
En el componente donde vamos a usar esta clase (en este ejemplo, Form03Component) debemos importarla. Lo hacemos en la lógica (form03.component.ts), añadiendo la siguiente línea:

`import { AmfFullUser } from '../../amf-classes/amf-full-user';
`

### MONTANDO EL FORMULARIO

En la lógica nos vamos a centrar en la parte donde se define la clase del componente, que es la que nos afecta a nosotros ahora. Lo primero que ves, en la línea 11, es que declaramos una variable, a la que he llamado `User`. Esta será luego el objeto que almacenará el usuario. De momento, simplemente la declaramos, así:

`public User;`

Lo siguiente que hacemos es crear unos placeholders para los campos de texto. Esto no tiene nada nuevo. En el artículo anterior ya lo hicimos. Sólo que ahora son más. Los ves entre las líneas 13 y 19, en form03.component.ts:
```ts
public placeholders = {
   realname: 'Teclea tu nombre y apellidos',
   username: 'Teclea tu nombre de usuario',
   userpass: 'Teclea tu contraseña',
   userconfimrpass: 'Repite tu contraseña',
   email: 'Teclea tu email'
 };
 ```

Ahora tenemos que declarar unas variables en las que se irán almacenando provisionalmente los datos que teclee el usuario, según los vaya tecleando. Como te digo, estas variables son provisionales. Luego, cuando el usuario pulse el botón para grabar el formulario se almacenarán en el objeto User. Las declaramos en un arreglo al que hemos llamado userData, entre las líneas 21 y 30, así:
```ts
public userData = {
   realname: '',
   username: '',
   password: '',
   confirmPassword: '',
   email: '',
   continent: '0',
   gender: 'H',
   upTo18: false
 };
 ```

A continuación vamos a declarar una serie de variables que definirán los campos de tipo radio button que usamos en el formulario para que el usuario indique su género. Como son sólo dos opciones, hemos optado por este tipo de campos. Lo que hacemos es declarar todas las propiedades de ambos objetos. La definición de los campos aparece entre las líneas 32 a 47:
```ts
public genders = {
   H: {
     label: 'Hombre',
     id: 'gender_H',
     value: 'H',
     name: 'genderOption',
     checked: false
   },
   M: {
     label: 'Mujer',
     id: 'gender_M',
     value: 'M',
     name: 'genderOption',
     checked: true
   }
 };
```

Ahora vamos a definir las propiedades del selector de continente. Esta vez hemos escogido un selector desplegable porque hay varias opciones de las que se deberá escoger una. Las propiedades de las opciones del selector las hemos declarado entre las líneas 49 a 86, así:

```ts

public continents = [
   {
     value: '0',
     text: 'Selecciona continente',
     selected: true,
     disabled: true
   },
   {
     value: 'EU',
     text: 'Europa',
     selected: false,
     disabled: false
   },
   {
     value: 'AM',
     text: 'América',
     selected: false,
     disabled: false
   },
   {
     value: 'AF',
     text: 'África',
     selected: false,
     disabled: false
   },
   {
     value: 'AS',
     text: 'Asia',
     selected: false,
     disabled: false
   },
   {
     value: 'OC',
     text: 'Oceanía',
     selected: false,
     disabled: false
   }
 ];
 ```

Por último (de momento), declaramos una variable que determinará el estado de activado o desactivado del botón de grabación, en la línea 88, así:
botonDesactivado = true;
En la vista (form03.component.html) el valor de esta variable se asigna a la propiedad disabled del botón, como vemos en la línea 65 de dicha vista:
```html
<input type='button' (click)='saveUser()' class='btn btn-primary' #sendButton value='Aceptar' [disabled]="botonDesactivado">
```

Ahora hacemos el formulario en la vista. Lo primero que nos llama la atención es la etiqueta que inicia, precisamente, el formulario. Hemos puesto un binding de eventos, de forma que, cuando se produzca un cambio en los valores del formulario se llame a un método de la lógica que comprobará si el botón tiene que permanecer desactivado, o debe activarse para poderse pulsar. Lo ves en la línea 3, así:

`<form (change)="checkButton()">`

El método CheckButton está definido en la lógica del componete, entre las líneas 90 y 101:

```ts
checkButton() {
   this.botonDesactivado = (
     this.userData.realname === '' ||
     this.userData.username === '' ||
     this.userData.password === '' ||
     this.userData.confirmPassword === '' ||
     this.userData.password !== this.userData.confirmPassword ||
     this.userData.email === '' ||
     this.userData.continent === '0' ||
     this.userData.upTo18 === false
   );
 }
 ```

Como ves, lo que hace es poner en `botonDesactivado` el resultado de comprobar si alguno de los campos está vacío, o si la clave no coincide con la confirmación. Y aquí es donde la cosa empieza a ponerse interesante. Realmente no estamos comprobando el valor de los campos, sino de las variables temporales que declaramos en el arreglo userData. Así pues, hay que lograr que cuando el usuario teclee algo en alguno de los campos, la correspondiente variable se actualice en tiempo real, de modo que, cuando se llame a este método, la variable tenga el valor tecleado por el usuario. Vamos a ver como lo hacemos, por ejemplo, con el primer campo (el que corresponde al nombre real del usuario). Lo tenemos declarado en la línea 7 de la vista:
```html
<input type='text' class='form-control' name="realName" #realnameField [placeholder]='placeholders.realname' [(ngModel)]='userData.realname'>
```
Es posible que te choque la parte en la que usamos la directiva ngModel para enlazar la propiedad userData.realName con el valor de este campo. Si recuerdas el artículo sobre binding de propiedades quizá estés pensando que lo suyo habría sido definir el campo así:
```html
<input type='text' class='form-control' name="realName" #realnameField [placeholder]='placeholders.realname' [value]='userData.realname'>
```

Esto, que, en otras circunstancias, podría valer, aquí nos da un problema. Para la propiedad value del campo se toma el contenido de la variable en la lógica (que, inicialmente, es una cadena vacía). Es un binding "hacia arriba". Sin embargo, cuando el usuario teclea algo, no se actualiza la variable en tiempo real. Para eso haría falta un binding "hacia abajo", es decir, un binding de eventos, con el evento `keyup`, o `change`, o similar. En todo caso, complicaría la escritura de la etiqueta, y nos obligaría a añadir más lógica. Usar la directiva `ngModel` enlaza directamente el campo de la vista con la propiedad de la lógica en tiempo real. Es decir. Si la variable cambiara dentro de la lógica, se vería inmediatamente el cambio en el valor del campo, y si el usuario teclea algo en el campo, se actualiza inmediatamente la variable en la lógica. Por eso ves que la directiva ngModel se encierra entre los dos signos de binding: el binding de eventos con los paréntesis, y el binding de propiedades con los corchetes. Esto hace que se produzca un doble binding, hacia arriba y hacia abajo, simultáneamente, en tiempo real. Esta notación (que siempre se hace con los paréntesis dentro de los corchetes, nunca al revés) se conoce, en el mundillo de Angular, con el pintoresco nombre de banana in a box.

Gracias a esto, las propiedades de userData en la lógica se actualizan en tiempo real. Y como, cada vez que se produce un cambio en el formulario, se comprueba cual debe ser el estado del botón (gracias al binding del evento change del formulario), cuando todos los campos están cumplimentados, el botón se habilita. Observa que todos los campos que deben influir en la habilitación o inhabilitación del botón usan la directiva ngModel con el doble binding, para mantener todas las propiedades de userData siempre actualizadas.

ATENCIÓN. Para que la directiva ngModel funcione correctamente, permitiendo hacer el doble binding que necesitamos, es necesario que se cumplan algunos requisitos:
- Que se utilice la notación banana in a box.
- Que el campo tenga establecida la propiedad name.
- Que hayamos importado el FormsModule de Angular en nuestro propio módulo, como vimos en el apartado anterior de este mismo artículo.

### MAS DETALLES SOBRE LA VISTA
Acabamos de aprender lo más importante de este ejecicio: el doble binding. Sin embargo, en la vista aún hay algunos detalles que debemos aprender. Por ejemplo, vamos a centrarnos en el selector desplegable que hemos usado para el continente. Mira como está declarado (líneas de la 36 a la 38):
```html
<select class="form-control" name="userContinent" [(ngModel)]="userData.continent">
   <option *ngFor="let continent of continents" [value]="continent.value" [selected]="continent.selected" [disabled]="continent.disabled">{{continent.text}}</option>
 </select>
 ```

En la etiqueta select usamos el doble binding, de modo que, cuando se cambie la opción elegida, se actualizará, como ya sabemos, en tiempo real, el valor de la propiedad `userData.continent` de la lógica. Sin embargo, lo que más nos interesa ahora es como se declara la lista de opciones. Observa que hemos usado la directiva estructural *ngFor para recorrer el arreglo donde definíamos las opciones en la lógica. Para cada iteración empleamos las propiedades value, selected, disabled y text del elemento sobre el que estamos iterando. El grupo de botones de radio, por ejemplo. Aquí usamos varios recursos que nos ofrece Angular. Mira como están definidos:
```html
<div class="col-sm-2">
   <label>
     <input type="radio" #{{genders.H.id}} [value]="genders.H.value" [name]="genders.H.name" checked [(ngModel)]="userData.gender">
     {{genders.H.label}}
   </label>
 </div>
 <div class="col-sm-2">
   <label>
     <input type="radio" #{{genders.M.id}} [value]="genders.M.value" [name]="genders.M.name" [(ngModel)]="userData.gender">
     {{genders.M.label}}
   </label>
 </div>
 ```
Observa, especialmente, como hemos usado las propiedades que definimos en el arreglo en la lógica. Incluso el identificador (el precedido por una #) se ha definido en la lógica, y se emplea mediante la interpolación de la correspondiente propiedad. Además, cada botón tiene su propia propiedad value, con lo que, al usar ngModel logramos que, cuando se haga clic sobre uno de los botones, se actualice la propiedad userData.gender en tiempo real con el value del botón pulsado.
Una vez que está correctamente cumplimentado el formulario, el botón de grabar queda activado. Al pulsarlo llamamos al método saveUser de la lógica. Este no tiene mayor misterio. Simplemente, crea un objeto de la clase AmfFullUser, y graba los valores de las variables temporales dentro. Lo vemos porque el objeto está montado en la vista con el pipe json, para serializarlo.

La parte de validación se mejora con la utilización de Reactive Forms.

## Validando formularios
Vamos a mejorar la aplicación anterior en los siguientes aspectos:
- El botón para grabar no estaba disponible hasta que habíamos cumplimentado todos los campos del formulario. Sin embargo, no es un sistema muy amigable. El usuario ve que el botón no está operativo, pero realmente no sabe por qué. 
- No sabe si tiene que rellenar todos los datos, o si algunos son opcionales; los campos de password están con el contenido oculto (como todos los campos de tipo password); 
- no sabe si es obligatorio marcar el checkbox de "mayor de edad"... 

En fin, que no le damos muchas pistas, y un usuario poco familiarizado con los formularios en Internet seguramente piense "Esta página no funciona" y salga para no volver a entrar.

Ahora vamos a enfocarlo de otro modo. El botón siempre estará habilitado y, si el usuario lo pulsa sin tener bien cumplimentado algún campo importante, le informaremos de ello mediante un mensaje cómodo y amigable. De esta forma, le guiamos paso a paso, para rellenar correctamente nuestro formulario.

### EN QUÉ CONSISTE LA VALIDACIÓN

Esto, que puede parecerles banal a algunos, es una cuestión que creo interesante comentar antes de empezar con este tema a nivel operativo. La validación tenemos que diseñarla nosotros antes de teclear una sóla línea de código. En concreto, tenemos que determinar lo siguiente:

- Qué campos serán obligatorios, y cuales serán opcionales.
- Cuál será la longitud mínima o máxima de un dato (en campos de texto).
- Cuáles serán los valores mínimo y máximo en campos numéricos.
- Cuantas opciones se podrán elegir, por ejemplo, en un selector múltiple.
- Si el aviso de error se mostrará al pulsar un botón de envío (por ejemplo) o al abandonar un campo.
- Y, en general, cualquier cosa que se nos ocurra como criterio.

Evidentemente, en casi la totalidad de los casos, las validaciones las aplicaremos sobre campos obligatorios. Si un campo es opcional, no tiene ningún sentido que le apliquemos reglas de validación.

El resultado sería algo así:

![](https://imgur.com/zq8k84R.png)

Podría ser un formulario para que se registraran personas que, por ejemplo, optaran a algún concurso, o a un puesto de trabajo. Como ves, tiene cuatro campos, que vamos a hacer obligatorios, aunque los vamos a validar de distintos modos, para ver las distintas posibilidades:
- El campo del nombre de usuario lo validaremos en tiempo real, según se teclea. 
- Los campos de contraseña, repetición de la contraseña y la selección de idiomas hablados los validaremos cuando el usuario pulse el botón. 

- Las reglas de validación serán las siguientes:
  + Para el nombre del usuario, es obligatorio teclear, al menos, cuatro caracteres. Le pondremos una limitación de un máximo de diez caracteres, aunque eso no pasará por validación, ya que el atributo maxlength de HTML limita físicamente el máximo de caracteres que se pueden teclear.
  + Para la contraseña pediremos un mínimo de seis caracteres, con una limitación máxima de diez.
  + Para la repetición de la contraseña se requerirá que el dato tecleado coincida con el del campo anterior.
  + Para la lista de idiomas hablados se requerirá que el candidato marque, al menos, tres de los que aparecen en la lista.

Veamos como montar todo el sistema de validaciones.

### EL PRIMER CAMPO

El primer campo es el que más atención nos va a merecer aquí. Dado que queremos que se valide en tiempo real, eso ya nos dice que el proceso de validado puede hacerse en la vista. Vamos a ver como está declarado el campo en form04.component.html:

```html
<input type="text"
   class="form-control"
   name="userNameField"
   [(ngModel)]="userName"
   required minlength="4" maxlength="10"
   #userNameModel="ngModel">
```

Como ves, hay varias cosas que ya conocemos, y otras que no tanto. Por ejemplo, vemos que hacemos doble binding con una propiedad llamada userName, que está definida en la lógica (form04.component.ts). 

También vemos una línea con reglas de validación. La regla required, que indica que es obligatorio cumplimentar el campo, es propia de HTML. También es el caso de la regla maxlength. Esta actúa físicamente sobre el campo, de modo que no nos va a permitir escribir más de diez caracteres, con lo cual ni siquiera tendremos que validar.

Otra cosa que nos llama la atención es el hecho de que **el identificador Angular** que le damos al campo (el que va precedido por #) hasta ahora nunca lo habíamos usado como una **propiedad, asignándole un valor**. Asumíamos que el propio identificador era el valor. Esto es así en otros casos, de los que ya hemos visto ejemplos, pero, además, permite una asignación, como en este caso específico. **Al asignarle ngModel estamos diciéndole que cuando se haga el binding hacia abajo del valor del campo, se valide éste conforme a las reglas de validación expresadas.**
Vamos a darle una vuelta a este punto porque al principio cuesta un poco familiarizarse con él. Cuando asignamos al identificador el valor ngModel al identificador del campo (en este ejemplo, userNameModel) se crea, automáticamente, una propiedad llamada **`errors`**. Esta contiene unos valores booleanos por cada regla de validación que hayamos especificado para comprobar. Por ejemplo, hemos especificado que el valor de este dato deberá tener una longitud mínima de cuatro caracteres. Bien. Pues esto le crea a userName una propiedad errors, con una propiedad `minlength`. Si el valor tiene menos de cuatro caracteres, este flag se activa, pasando a valer true. Cuando el valor tiene más de cuatro caracteres, la propiedad userNameModel.errors.minlength valdrá false.
Además, se crea una propiedad llamada `invalid` (realmente userNameModel.invalid), que se pone a true si el campo es inválido, es decir, si rompe alguna de las reglas de validación. También se le crea una propiedad `dirty` (userNameModel.dirty), que se pone a true cuando se cambia por primera vez el valor del campo. Así mismo, se crea una propiedad `touched` (userNameModel.touched), que se pone a true la primera vez que se saca el foco del campo (evento blur). Y todo esto se crea y se gestiona automáticamente (Angular se ocupa de ello). Nosotros sólo tenemos que leer el valor de esas propiedades para determinar si están a true o a false, es decir, ver que estas propiedades nos informen de que se ha roto alguna de las reglas de validación.
Para ver estas propiedades, y el resultado de la validación, nos vamos un poco más abajo, al siguiente fragmento de la vista:
```html
<div class="row alert alert-danger" *ngIf="mensajeDeError || (userNameModel.invalid && userNameModel.touched)">
   <div *ngIf="userNameModel.invalid">
     <h3>Error en el nombre de usuario</h3>
     <span *ngIf="userNameModel.errors.required">
       <p>Este campo es obligatorio</p>
     </span>
     <span *ngIf="userNameModel.errors.minlength">
       <p>Debes teclear 4 caracteres o más</p>
     </span>
   </div>
   <div *ngIf="errorPass">
     <h3>Error en contraseña</h3>
     <p>La contraseña es demasiado corta</p>
   </div>
   <div *ngIf="errorConfirmPass">
     <h3>Error en confirmación de contraseña</h3>
     <p>La confirmación no coincide con la contraseña</p>
   </div>
   <div *ngIf="errorLanguages">
     <h3>Idiomas insuficientes</h3>
     <p>Debes hablar, al menos, tres idiomas de la lista.</p>
   </div>
 </div>
 ```

Lo que hacemos es crear una capa con las clases de bootstrap que le dan el color rojo de error, conteniendo los mensajes de los errores encontrados en el formulario. La existencia de esta capa en el DOM está supeditada, por una parte, a la variable mensajeDeError, que se actualizará cuando pulsemos el botón. Eso lo veremos en seguida. También está supeditada a que se detecten las propiedades userNameModel.invalid y userNameModel.touched, que ya sabemos que son actualizadas, en tiempo real, por Angular.
En la capa se avisa, entre otras cosas, de errores en la contraseña o en la lista de idiomas seleccionados. En eso no vamos a fijarnos por ahora. Lo que nos importa es el mensaje relativo al nombre de usuario, que se muestra si no cumple las reglas de validación. La validación de este campo se efectúa, por lo tanto, en la vista en tiempo real. No es necesario pulsar el botón para que se haga esta comprobación.

:warning: Es posible que el editor de VSC te marque cómo erróneas las lecturas de las propiedades userNameModel.errors.required y userNameModel.errors.minlength. Habiendo definido en el campo las validaciones required y minlength no hay tal error. Es sólo cosa del VSC. Ignora el aviso y, cuando ejecutes la aplicación, verás que no hay ningún problema. Incluso, durante la ejecución puedes abrir la consola del navegador, y verás que queda limpia, sin errores. Es una pequeña debilidad de VSC, algo molesta visualmente, pero no tiene importancia.

### EL RESTO DE LOS CAMPOS

El resto de los campos no tienen montado este mecanismo. Se validan en un método de la lógica, cuando se pulsa el botón. Conceptualmente es mucho más simple, por lo que yo prefiero este último sistema. De hecho, sólo he usado la validación en tiempo real en el primer campo para que veas como se hace, y para que si encuentras código como ése, sepas lo que se está haciendo. Es posible que en algún proyecto tuyo necesites una validación en tiempo real en la vista, pues ya sabes cómo hacerlo.
Cuando se pulsa el botón, se ejecuta una función que comprueba si alguna de las variables que reciben los valores de los campos no se ajusta a lo que deseamos, y muestra la capa roja de error. Si todos los campos están bien, se muestra una capa verde, indicando que todo ha ido bien. 
