# Iniciación al enrutamiento

## Introducción

La definición de rutas es necesaria dentro de nuestras aplicaciones para:
- separar diferentes áreas de la aplicación;
- mantener el estado en la aplicación;
- proteger áreas de la app basados en ciertas reglas (ej. área administrativa);

En Angular se trabaja el enrutamiento del lado de cliente. Las vistas no vienen renderizadas de un servidor sino que es JavaScript quien se encarga de servir distintas páginas.

## CREANDO EL ENRUTAMIENTO RAÍZ

Vamos a empezar creando el enrutamiento. El sistema de enrutamiento de Angular se basa en crear una relación entre la información de la barra de direcciones, y el componente al que llegaremos según el contenido de esa información. Se pueden crear enrutamientos globales a la aplicación, que nos permitirán acceder a todas o la mayoría de las secciones, y enrutamientos de módulo, que se crean en un módulo específico para acceder a las vistas de distintos componentes de ese módulo. 

Vamos a empezar por el enrutamiento raíz.
 
Como es lógico, todo lo que tenga que ver con la raíz del sitio estará en AppComponent, o muy íntimamente relacionado con dicho componente. En concreto, para crear el enrutamiento raíz iremos al archivo **app-routing.module.ts**. Ya el nombre nos dice que tiene que ver con el enrutamiento. Su aspecto inicial es el siguiente:

```ts
import { NgModule } from '@angular/core';
 import { Routes, RouterModule } from '@angular/router';
  const routes: Routes = [];
  @NgModule({
   imports: [RouterModule.forRoot(routes)],
   exports: [RouterModule]
 })
 export class AppRoutingModule { }
```

Existen tres componentes principales en el enrutamiento de Angular:

- **Routes**. Son las rutas que soporta la aplicación
- **RouterOutlet** es un componente de indicaciones "placeholder" que muestra a Angular donde incorporar el contenido de cada ruta
- **RouterLink**. Directiva utilizada para conectar las rutas

En el AppRoutingModule se importan `Routes` y `RouterModule`. `RouterModule` es un módulo como los que creamos nosotros, pero que ha sido creado por el propio Angular, para hacer funcionar el sistema de enrutamiento. `Routes` es un array de objetos de tipo `Route`. 

En el decorador vemos que este archivo no tiene propiedad declarations, y no la necesita. Solo importa el módulo RouterModule y lo exporta. Observa que en la importación le añadel método `forRoot(routes)`. El argumento routes es el array definido anteriormente. El método `forRoot()` indica que este enrutamiento es para la raíz del sitio. Los enrutamientos de otros módulos (ya lo veremos) emplean un método parecido que se llama `forChild()`, que veremos luego.
Vemos que se finaliza el enrutamiento exportando toda la clase, como ves en la última línea.
Por lo tanto, se importa el módulo de enrutamiento, se definen las rutas en el array routes y se exporta el enrutamiento con esas rutas definidas. 

Y ¿a dónde se exporta? ¿Recuerdas la vista de AppComponent? La última línea es `<router-outlet></router.outlet>`. Esto, que parece una etiqueta HTML personalizada de Angular es, una directiva. 
Las directivas son instrucciones especiales de Angular que se integran en los componentes para ampliar las funcionalidades del HTML. En concreto, esta directiva "recibe" el enrutamiento, y permite que funcione.

### CREANDO EL ARRAY DE LAS RUTAS

Vamos a modificar el array `routes` para que podamos acceder, de momento, a la pagina principal del sitio, y a la vista del listado de clientes y de proveedores (luego ya añadiremos accesos para más módulos y componentes). 

El app-routing.module.ts nos queda así:

```ts
import { NgModule } from '@angular/core';
 import { Routes, RouterModule } from '@angular/router';
  import { HomeComponent } from './commons/home/home.component';
 import { CustomersListComponent } from './customers/customers-list/customers-list.component';
 import { SuppliersListComponent } from './suppliers/suppliers-list/suppliers-list.component';
  const routes: Routes = [
   {
     path: '',
     component: HomeComponent
   },
   {
     path: 'clientes',
     component: CustomersListComponent
   },
   {
     path: 'proveedores',
     component: SuppliersListComponent
   }
 ];
  @NgModule({
   imports: [RouterModule.forRoot(routes)],
   exports: [RouterModule]
 })
 export class AppRoutingModule { }
```

Empecemos por mirar el primer bloque (líneas 4, 5 y 6). Como vamos a enrutar tres módulos (HomeComponent, que será nuestra vista principal, CustomersListComponent, que será la lista de clientes y SuppliersListComponent, que será la lista de proveedores) lo primero que tenemos que hacer es importar esos componentes. Para que esto funcione correctamente, dichos componentes deberán ser exportables y los módulos que los contienen deberán estar importados en app.module.ts.

:warning: Si estás usando el VSC con las extensiones adecuadas, cuando crees un objeto route y escribas el nombre del componente te hará la importación automáticamente, por lo que te evitas escribir la instrucción import correspondiente.
A continuación, dentro del array routes incluimos tres objetos en notación JSON, que se refieren a las rutas a través de las cuales se alcanzarán los tres componentes. Observa que cada objeto tiene dos propiedades: path, que es donde se define la ruta que habrá que teclear en el navegador para acceder a un componente, y component, que será el componente al que se accederá a través de dicha ruta. Como nuestra aplicación arranca en localhost:4200, la ruta que especifiquemos en path será a partir de ahí.
Por ejemplo, para entendernos, fíjate en la primera ruta. El valor de path es una cadena vacía. Eso quiere decir que cuando en la barra de direcciones aparezca localhost:4200, sin nada más, se cargará HomeComponent. Es decir, nuestra vista de inicio ya no será AppComponent, sino HomeComponent.
Si tecleamos en la barra de direcciones localhost:4200/clientes se cargará en el viewport la vista de CustomersListComponent, porque ese es el path y component definido en el segundo objeto de routes. Por lo mismo, si tecleamos localhost:4200/proveedores se cargará SuppliersListComponent.
 
Fíjate en la ruta que hay en la barra de navegación, y en que la vista que se carga ya no es la de AppComponent, sino la de HomeComponent. ¿Correcto? Pues no del todo. Es cierto que se carga la vista de HomeComponent (lo vemos por el texto Página principal de la aplicación, que se define en home.component.html). Sin embargo, también se carga la cabecera y la barra de navegación, que están insertadas en AppComponent, y no en HomeComponent. Es decir, AppComponent se cargará siempre, sí o sí, con independencia de que, además, se cargue otro componente. Y esa es la razón por la que en app.component.html no metemos código HTML, sino sólo aquello que queramos incluir en todas las vistas de la aplicación (como la barra de navegación y la cabecera de página). Si estos elementos los quisiéramos sólo en algunas vistas, pero no en otras, tampoco los incluiríamos en app.component.html, sino en cada una de las vistas donde los necesitemos.


### LA PÁGINA 404

Tenemos definida una vista específica para los errores 404 (página no encontrada), en `NotFoundComponent`, pero aún no tenemos ninguna forma de que esta vista se cargue cuando el usuario teclea, en la barra de direcciones, una página que no existe en nuestro sitio. Vamos a ampliar un poco más el listado de rutas en app-routing.module.ts:

```ts
import { NgModule } from '@angular/core';
 import { Routes, RouterModule } from '@angular/router';
  import { HomeComponent } from './commons/home/home.component';
 import { CustomersListComponent } from './customers/customers-list/customers-list.component';
 import { SuppliersListComponent } from './suppliers/suppliers-list/suppliers-list.component';
 import { NotFoundComponent } from './commons/not-found/not-found.component';
  const routes: Routes = [
   {
     path: '',
     component: HomeComponent
   },
   {
     path: 'clientes',
     component: CustomersListComponent
   },
   {
     path: 'proveedores',
     component: SuppliersListComponent
   },
   {
     path: '404',
     component: NotFoundComponent
   },
   {
     path: '**',
     redirectTo: '404'
   }
 ];
  @NgModule({
   imports: [RouterModule.forRoot(routes)],
   exports: [RouterModule]
 })
 export class AppRoutingModule { }
```

Vamos a fijarnos en la línea 7, donde importamos el NotFoundComponent, para que esté disponible para el enrutador. Ahora mira las líneas de la 22 a la 25. Esto hace que si el usuario teclea localhost:4200/404 se cargue la vista de NotFoundComponent. Sin embargo, no es normal que un usuario teclee eso. Lo normal es que un error de este tipo venga definido por algo como localhost:4200/cualquiercosa. En ese caso entra en juego el último objeto de ruta definido, en las líneas de la 26 a la 29. Cuando ponemos, en la propiedad path, el valor **`**`** significa que cualquier dirección que se teclee y no coincida con los path definidos previamente, activará este componente. Sin embargo, en este objeto no tenemos la propiedad component, sino redirectTo. Eso hace que si lo tecleado en la barra de direcciones no coincide con ningún path anterior (lo que quiere decir que coincide con '**') se redirija al path definido como '404'.
Y claro. seguramente estarás pesando que estos dos últimos objetos de ruta se podrían haber "fundido" en uno solo, que fuera así:

```ts
{
   path: '**',
   component: NotFoundComponent
 }
```

Y tienes toda la razón. Lo único que quería era enseñarte que en un objeto de ruta no tiene por qué existir siempre la misma estructura de propiedades. 

Sólo recuerda que path: '**' es un comodín, por lo que debe definirse al final de todos los objetos de ruta, de modo que sólo "entre" aquí si no ha habido coincidencias anteriores.

### LOS ENLACES DE LA BARRA DE NAVEGACIÓN

Aún tenemos nuestra barra de navegación con sólo tres enlaces, aunque tenemos más componentes. Eso ahora no importa. Ya añadiremos los que nos faltan. Lo que sí que importa es que los enlaces que tenemos aún no funcionan, y vamos a hacerlos funcionar ahora.
Lo primero que tenemos que hacer es ir a donde tenemos definido el HTML de la barra de navegación, es decir, en `navbar.component.html`. En este componente sustituiremos, en todos los enlaces, la propiedad href por `routerLink`. Esta no es una propiedad normalizada de HTML, y esto no nos funcionaría en una barra de navegación que fuera parte de un proyecto no Angular. La propiedad routerLink es propia de Angular, y se ha diseñado para que los enlaces "casen" con los objetos route que hemos definido en el enrutador.
A continuación, a la propiedad routerLink le asignaremos, en cada enlace, el valor que coincida con la propiedad path de la ruta correspondiente. El navbar.component.html nos quedará, por lo tanto, así:

```html
<nav class='navbar navbar-expand-sm navbar-dark bg-dark'>
   <a class='navbar-brand' [routerLink]=''>App Angular</a>
   <button class='navbar-toggler' type='button' data-toggle='collapse' data-target='#menuBar' aria-controls='menuBar' aria-expanded='false'
     aria-label='Toggle navigation'>
     <span class='navbar-toggler-icon'></span>
   </button>
    <div class='collapse navbar-collapse' id='menuBar'>
     <ul class='navbar-nav mr-auto'>
       <li class='nav-item'>
         <a class='nav-link' [routerLink]="['']">Inicio</a>
       </li>
        <li class='nav-item'>
         <a class='nav-link' [routerLink]="['clientes']">Clientes</a>
       </li>
        <li class='nav-item'>
         <a class='nav-link' [routerLink]="['proveedores']">Proveedores</a>
       </li>
      </ul>
   </div>
 </nav>
 ```

Luego mejoraremos algo su comportamiento pero, por ahora, si los pruebas, verás que funcionan perfectamente.

:warning: Es posible que encuentres aplicaciones Angular donde se emplee la propiedad estándar href, en lugar de routerLink. En muchos casos, funcionará, aparentemente, igual, pero sólo aparentemente. Internamente, Angular espera routerLink, no href y, en algunos casos, puede darte errores. 
 
:warning: Cuando creamos una barra de navegación, esta es un componente que, como norma general, formará parte de un módulo. En este ejemplo le hemos llamado CommonsModule, pero puede tener otro nombre. Al ser un componente que va a ser común a toda la aplicación (o a gran parte de ella), estará en un módulo llamado CommonsModule, o GlobalsModule, o algún otro nombre similar que haga referencia a componentes globales. La cuestión es la siguiente: en la lógica del módulo (en nuestro caso, commons.module.ts) debemos importar el modulo RouterModule de Angular. En las líneas de importación que se colocan al principio del archivo deberemos tener una línea como la siguiente:

```ts
import { RouterModule } from '@angular/router';
```

Además, en el decorador @NgModule, en la propiedad imports deberemos tener, entre otras, la importación de RouterModule.

## Lazy Load (carga diferida)

La carga perezosa, también llamada carga diferida, o lazy load, es uno de los puntos fuertes del sistema de enrutamiento en Angular. De hecho, es una técnica muy empleada en muchos entornos de desarrollo, pero que adquiere un especial sentido en el trabajo con SPA's, sobre todo si pensamos que nuestra aplicación pueda ser empleada por usuarios de dispositivos móviles, u otras conexiones más lentas de lo habitual.
La carga perezosa consiste en que sólo se cargue la vista de inicio de la aplicación, o las vistas que sepamos, por experiencia, que son más consultadas. El resto de las vistas no se cargarán en el navegador del cliente a menos que éste las solicite expresamente (pulsando un enlace, por ejemplo). De este modo, las vistas que no son invocadas por el cliente no se cargan, y no consumen recursos de la conexión.

### LO QUE SE CARGA Y LO QUE NO SE CARGA

Empecemos por el principio. Sabemos que cuando se pone en marcha el servidor de Angular, el webpack lleva a cabo varias tareas. Te hablé sobre el webpack en este artículo, por si quieres repasarlo. Su misión es transpilar el código TypeScript a JavaScript, organizarlo en paquetes (archivos .js) y mandarlo todo al navegador. Parte de esos archivos .js son funcionalidades propias de Angular, por lo que éstas siempre se cargarán al arranque de la aplicación, sí o sí. Sin embargo, hay un JavaScript llamado main.bundle.js, que es la compilación de los módulos y componentes que se cargan directamente, es decir, que no usan carga perezosa. Los módulos y componentes que usan carga perezosa no se incluyen en este script, sino que son transpilados aparte, y sólo se envían al navegador si son solicitados.

### EL ESCENARIO

Seguimos trabajando a partír de la aplicación que ya tenemos "a medio hacer". En este artículo le vamos a añadir un enlace más a la barra de navegación para acceder al módulo de almacén (llamado StoringModule). Sin embargo, al contrario que los anteriores, este lo cargaremos en diferido, es decir, sólo si el usuario pulsa el enlace. En caso contrario, no se cargará en el navegador, y no consumirá recursos. Realmente, este será un menú desplegable que dará acceso a los tres componentes del módulo StoringModule.

### MÓDULOS CON ENRUTAMIENTO INTERNO

Para cargar componentes en lazy load, los módulos donde estos se encuentren han tenido que crearse con su propio sistema de routing. Si un módulo se ha creado sin enrutamiento propio (es decir, sin usar el flag --routing en la creación, tal cómo comentamos en este artículo), ya tenemos un problema. Esto es así, porque, desde nuestros enlaces (pongamos el caso de la barra de navegación, o cualquier otro sistema de enlaces) no podemos acceder a los componentes del módulo. En lazy load se accede a la carga del módulo (la generación del archivo tipo .chunk.js), pero no a un componente específico. Por lo tanto es imprescindible que el módulo tenga su propio enrutador.
Y aquí se presenta un problema. ¿Que hago si un módulo ha sido creado sin enrutador y ahora lo necesito para la carga diferida?

### MÓDULO CON ENRUTADOR Y SIN ENRUTADOR

Cuando creas un módulo este se coloca en una carpeta específica dentro de la estructura de directorios de Angular(1). Si el módulo se crea sin enrutamiento, en esta carpeta aparece un archivo, con el nombre del módulo, seguido de la partícula .module y la extensión .ts. Si el módulo se crea con enrutamiento propio, se crean dos archivos. Uno se llama igual que en el caso anterior y el otro se llama con el nombre del módulo, seguido de -routing.module.ts. Cómo ya hemos creado varios módulos, te supongo más o menos familiarizado con esto.

(1) Puedes crear un módulo, o un componente, sin que se organice en una carpeta propia usando, para la generación, el modificador --flat. Sin embargo, esto te puede llevar a tener un batiburrillo de archivos desorganizados, que no sepas donde está cada cosa. Yo lo desaconsejo encarecidamente.


Creamos un módulo sin enrutamiento, así:

`ng g m module01`

Esto nos crea un módulo llamado Module01Module, con un archivo llamado module01.module.ts. Si ahora necesitamos añadirle un sistema de enrutamiento propio, deberemos crear un archivo llamado module01-routing.module.ts, cuyo listado es el siguiente:

```ts
import { NgModule } from '@angular/core';
 import { Routes, RouterModule } from '@angular/router';
  const routes: Routes = [];
  @NgModule({
   imports: [RouterModule.forChild(routes)],
   exports: [RouterModule]
 })
 export class Module01RoutingModule { }
 ```

El archivo base es siempre el mismo, así que solo tendrías que copiar este archivo en el directorio del módulo que creaste sin enrutamiento y al que se lo quieres añadir. Lo único que cambia es el nombre de la clase que se exporta (línea 10), que debe empezar con el nombre del módulo donde se crea este sistema de enrutamiento.
También quiero llamar tu atención sobre una cosa. Si lo miras, verás que este archivo es muy parecido al app-routing.module.ts, salvo por un detalle en la línea 7. En el decorador del archivo del enrutamiento raíz (el que hemos usado en el artículo anterior), se importaba RouterModule con el método forRoot(), lo que quería decir que ese enrutamiento era para la raíz del sitio o, si lo prefieres, global al sitio. En los enrutamientos de los módulos que crees tú se usa forChild(). Es el equivalente, pero para enrutamientos de módulos que están, jerárquicamente, "por debajo" de AppModule. En una aplicación Angular puede haber todos los enrutamientos que necesites que usen el método forChild(), pero sólo uno (el de AppModule) que use el método forRoot().
Además, hay que decirle al archivo *.module.ts que vamos a usar enrutamiento. En nuestro ejemplo, el archivo module01.module.ts debe ser modificado para poder usar el enrutamiento interno. El original (cuando se creo sin enrutamiento interno) es así:

```ts
import { NgModule } from '@angular/core';
 import { CommonModule } from '@angular/common';
  @NgModule({
   imports: [
     CommonModule
   ],
   declarations: []
 })
 export class Module01Module { }
 ```

Para añadirle el enrutamiento interno se queda así:

```ts
import { NgModule } from '@angular/core';
 import { CommonModule } from '@angular/common';
  import { Module01RoutingModule } from './module01-routing.module';
  @NgModule({
   imports: [
     CommonModule,
     Module01RoutingModule
   ],
   declarations: []
 })
 export class Module01Module { }
 ```


### LA BARRA DE NAVEGACIÓN

Para ver como funciona la carga diferida, vamos a echarle un vistazo rápido a la barra de navegación. Le hemos añadido una opción que hemos llamado Storing que, por sí, no carga nada. Solo despliega un menú con tres opciones. Lo que queremos es que, cuando se pulse una de esas tres opciones por primera vez, se produzca la carga diferida del módulo de almacén (StoringModule) con el componente que corresponda a la opción elegida. El archivo navbar.component.html queda así:

```html
<nav class='navbar navbar-expand-sm navbar-dark bg-dark'>
   <a class='navbar-brand' routerLink=''>App Angular</a>
   <button class='navbar-toggler' type='button' data-toggle='collapse' data-target='#menuBar' aria-controls='menuBar' aria-expanded='false'
     aria-label='Toggle navigation'>
     <span class='navbar-toggler-icon'></span>
   </button>
    <div class='collapse navbar-collapse' id='menuBar'>
     <ul class='navbar-nav mr-auto'>
       <li class='nav-item'>
         <a class='nav-link' routerLink=''>Inicio</a>
       </li>
        <li class='nav-item'>
         <a class='nav-link' routerLink='clientes'>Clientes</a>
       </li>
        <li class='nav-item'>
         <a class='nav-link' routerLink='proveedores'>Proveedores</a>
       </li>
        <li class="nav-item dropdown">
         <a class="nav-link dropdown-toggle" href="#" id="dropdown_almacen" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Almacén</a>
         <div class="dropdown-menu" aria-labelledby="dropdown_almacen">
           <a class="dropdown-item" routerLink="almacen">Listado</a>
           <a class="dropdown-item" routerLink="almacen/entradas">Entradas</a>
           <a class="dropdown-item" routerLink="almacen/salidas">Salidas</a>
         </div>
       </li>
      </ul>
   </div>
 </nav>
 ```

Observa especialmente las líneas resaltadas. Ves que las tres opciones del submenú del almacén van a enlaces que empiezan con la partícula almacen. El primero sólo tiene esa partícula, y los otros dos tienen rutas que "cuelgan" de esa partícula. Y ¿a donde nos llevan esos enlaces?

### EL ARCHIVO DE ENRUTAMIENTO RAÍZ

En el archivo de enrutamiento raíz (app-routing.module.ts) hemos creado un nuevo objeto route, un poco especial, como ves a continuación:

```ts
import { NgModule } from '@angular/core';
 import { Routes, RouterModule } from '@angular/router';
  import { HomeComponent } from './commons/home/home.component';
 import { CustomersListComponent } from './customers/customers-list/customers-list.component';
 import { SuppliersListComponent } from './suppliers/suppliers-list/suppliers-list.component';
 import { NotFoundComponent } from './commons/not-found/not-found.component';
  const routes: Routes = [
   {
     path: '',
     component: HomeComponent
   },
   {
     path: 'clientes',
     component: CustomersListComponent
   },
   {
     path: 'proveedores',
     component: SuppliersListComponent
   },
   {
     path: 'almacen',
     loadChildren: './storing/storing.module#StoringModule'
   },
   {
     path: '**',
     component: NotFoundComponent
   }
 ];
  @NgModule({
   imports: [RouterModule.forRoot(routes)],
   exports: [RouterModule]
 })
 export class AppRoutingModule { }
 ```

Fíjate que, a pesar de que en la barra de navegación tenemos tres opciones de almacén, en el archivo de enrutamientos sólo hemos creado una ruta. Observa que tiene, en la propiedad path, el valor 'almacen', que es la parte común con la que empiezan las tres opciones del menú en la barra de navegación. También vemos que no tiene propiedad component, por lo que, a la carga de la aplicación, no se carga nada para acceder al almacén, que es lo que pretendíamos. En su lugar, le hemos añadido la propiedad loadChildren. Esto hace que, cuando se pulse un enlace que apunte a almacen, o a "algo" que empiece por almacen/, será cuando se cargue el módulo especificado. Como valor de loadChildren ponemos la ruta relativa hasta el módulo que queremos cargar, el signo # y el nombre del módulo que queremos cargar.
Observa también que StoringModule no es importado junto con los demás módulos en las líneas de importaciones de la parte superior del script.
Es decir. Cuando se llame a un routerLink que sea almacen, o que empiece por almacen/, será cuando se cargue el módulo StoringModule, no antes. Sin embargo, fíjate que esto es sólo una ruta, pero tenemos tres enlaces. Esto no discierne a que componente del módulo queremos llamar. Y aquí es donde entra en juego el enrutador interno de StoringModule.

### EL ENRUTADOR INTERNO
Efectivamente, una vez que se carga el módulo en memoria, hace falta discernir cual de los tres enlaces que tenemos que apuntan a componentes de este módulo ha sido pulsado. Eso nos lo da el enrutador interno del módulo. Por eso te decía antes que para cargar un módulo en diferido, este tiene que tener un enrutador interno. El storing-routing.module.ts nos queda así:

```ts
import { NgModule } from '@angular/core';
 import { Routes, RouterModule } from '@angular/router';
  import { StoringListComponent } from './storing-list/storing-list.component';
 import { StoringIncomingComponent } from './storing-incoming/storing-incoming.component';
 import { StoringOutgoingComponent } from './storing-outgoing/storing-outgoing.component';
  const routes: Routes = [
   {
     path: '',
     component: StoringListComponent
   },
   {
     path: 'entradas',
     component: StoringIncomingComponent
   },
   {
     path: 'salidas',
     component: StoringOutgoingComponent
   }
 ];
  @NgModule({
   imports: [RouterModule.forChild(routes)],
   exports: [RouterModule]
 })
 export class StoringRoutingModule { }
```

Empieza por ver las líneas 4, 5 y 6, donde se importan los tres componentes que se emplean en este módulo. A continuación tenemos las routes, que se crean siguiendo el mismo esquema que en el enrutador raíz, mediante objetos que definen un path y el component al que apunta. Hay dos cosas que, seguramente, te llaman la atención: una es que el primer path recibe una cadena vacía, lo que parece que puede entrar en colisión con un path similar que hay en el enrutador principal; la otra es que no hay un path: '**' para redireccionar en el caso de páginas no existentes. Hablemos de estos dos puntos.

### LA RUTA "VACÍA"
Tienes que entender una cosa. Como estamos en un enrutador interno de un módulo, que jerárquicamente está "por debajo" del módulo raíz, la ruta path: '' no se refiere a que esté vacía a partir de localhost:4200, sino a partir de localhost:4200/almacen. Es decir. Para llegar aquí ya hemos tenido que acceder a almacen, por lo que una ruta vacía, en este enrutador es, digámoslo así, "relativamente" vacía. Observa las otras dos rutas. La ruta path: 'entradas' coincide con el routerLink de la barra de navegación almacen/entradas y path: 'salidas' coincide con el routerLink de la barra de navegación almacen/salidas.
Cuando usamos un enrutamiento interno, las rutas siempre son relativas a la ruta principal que cargó el módulo (en este ejemplo, el prefijo almacen).

### LA RUTA PARA 404

En los enrutamientos internos de módulos no se pone una ruta para páginas no encontradas porque, al estar esto previsto en el enrutamiento raíz, que es global a todo el sitio, esta salida nos funciona estemos donde estemos. No necesitamos más salidas de NotFound.

## Rutas con parámetros en carga directa

Vamos a empezar a ver las rutas con parámetros, es decir, que, al acceder a una vista, podamos pasarle uno o más parámetros, y la vista reciba esos parámetros para poder procesarlos.
En una aplicación como la que estamos creando podría ser bueno, por ejemplo, para que al seleccionar la lista de clientes nos muestre una serie de enlaces, relativos a cada uno de los clientes. Al pulsar un enlace nos mostraría la ficha del cliente correspondiente. Todos los enlaces van a la misma vista, y lo único qu cambia es el cliente que muestra.
Esto se puede hacer en módulos de carga directa, o en módulos de carga diferida. El concepto es el mismo, aunque, con los de carga directa (como es el caso de nuestra sección de clientes), y los de carga diferida hay algunos detalles diferentes.
El proceso es un poco complejo de entender la primera vez, pero luego verás que es, conceptualmente, muy lógico y limpio.

### LO QUE NECESITAMOS

Lo que vamos a hacer en este artículo es incorporar en la vista de clientes una lista de los clientes registrados. Por supuesto, en caso de una aplicación real, estos datos procederían de una API, o un Web Service, que nos los proporcionase a partir de una base de datos. Sin embargo, dado que aún no hemos hablado de comunicaciones con el servidor, los vamos a crear en código, como datos "fijos".
El siguiente paso es crear los enlaces de forma que carguen el componente CustomerDataComponent, que ya tenemos creado, pero que aún no tiene contenido.
Y hay que entender esto. Evidentemente, no se va a crear una ruta y un componente por cada cliente. El componente y su vista serán siempre los mismos, y en la ruta incorporaremos un parámetro que, en este ejemplo, será el identificador del cliente. Puede ser un ID, su CIF o lo que decidamos. En una aplicación real (y volvemos a lo mismo) a partir de ese identificador se obtendrían los datos del cliente de una base de datos. Aquí los vamos a tener como datos "fijos". A lo otro ya llegaremos. Después de todo, por ahora sólo se trata de ver cómo pasar parámetros en la ruta, y recibirlos en el componente de destino para hacer "algo" con ellos.

### LA LISTA DE CLIENTES
Vamos a modificar la vista de CustomersListComponent (customer-list.component.html) para incluir los enlaces a la vista de datos de cliente, con los identificadores de los supuestos clientes, así:

```html
<div class='container'>
   <h1>Listado de clientes</h1>
 </div>
  <div class='container'><hr></div>
  <div class='container'>
   <ul>
     <li><a routerLink='../ver_cliente/108'>Cliente 108</a></li>
     <li><a routerLink='../ver_cliente/227'>Cliente 227</a></li>
     <li><a routerLink='../ver_cliente/305'>Cliente 305</a></li>
     <li><a routerLink='../ver_cliente/543'>Cliente 543</a></li>
   </ul>
 </div>
 ```

Observa los enlaces. En cada uno se llama a la misma ruta (que en seguida definiremos en el enrutador), seguida de una barra y un identificador de cliente, que es el parámetro variable que pasamos en la ruta. Es decir, apuntamos siempre a la misma ruta, pero con un parámetro que cambia en cada llamada. Y observa también que el enlace empieza por "subir un nivel", es decir, con ../. Esto es porque el componente del listado de clientes no está en el módulo raíz de la aplicación, si no en un módulo que está a la misma altura jerárquica que la vista de la ficha de cliente. En cuanto veas el enrutador lo entenderás.

### EL ENRUTADOR

Para esto vamos a usar el enrutador raíz, es decir, app-routing.module.ts. La razón de usar este enrutador es que, como el módulo de clientes lo cargamos en directo, es decir, sin lazy load, y el enlace de la lista de clientes en la barra de navegación también apunta a una ruta de este enrutador, así tenemos las rutas organizadas en el mismo script de enrutamiento. Le añadimos la route correspondiente, así:

```ts
import { NgModule } from '@angular/core';
 import { Routes, RouterModule } from '@angular/router';
  import { HomeComponent } from './commons/home/home.component';
 import { CustomersListComponent } from './customers/customers-list/customers-list.component';
 import { CustomerDataComponent } from './customers/customer-data/customer-data.component';
 import { SuppliersListComponent } from './suppliers/suppliers-list/suppliers-list.component';
 import { NotFoundComponent } from './commons/not-found/not-found.component';
  const routes: Routes = [
   {
     path: '',
     component: HomeComponent
   },
   {
     path: 'clientes',
     component: CustomersListComponent
   },
   {
     path: 'ver_cliente/:id',
     component: CustomerDataComponent
   },
   {
     path: 'proveedores',
     component: SuppliersListComponent
   },
   {
     path: 'almacen',
     loadChildren: './storing/storing.module#StoringModule'
   },
   {
     path: '**',
     component: NotFoundComponent
   }
 ];
  @NgModule({
   imports: [RouterModule.forRoot(routes)],
   exports: [RouterModule]
 })
 export class AppRoutingModule { }
 ```

Observa la ruta en las líneas de la 19 a la 22. La hemos llamado con el mismo nombre que el enlace en customers-list.component.html. Es lo mismo que hacemos con las demás rutas, que las llamamos como aparecen en los enlaces de la barra de navegación. Sin embargo, la ruta que nos interesa ahora tiene una peculiaridad. Después del nombre de la propia ruta tiene la partícula /:id. Esto significa dos cosas: que la ruta continúa con otra ruta relativa (de ahí el slash /) y que lo que viene a continuación se debe entender como un parámetro. Esto nos lo indica el signo de dos puntos (:) que precede a id. El nombre id que le hemos dado al parámetro lo elegimos nosotros al construir la ruta.
Y aquí vemos la razón de que los enlaces de la vista del componente de listado de clientes los precediéramos con ../. Como ambos componentes están al mismo nivel jerárquico, y tenemos que pasar de uno a otro, si no "subimos" un nivel la vista de detalle del cliente se buscaría un nivel por debajo de la lista de clientes. Es decir, los enlaces, desdel listado de clientes, apuntarían, por ejemplo, a localhost:4200/clientes/ver_cliente/108 en lugar de apuntar localhost:4200/ver_cliente/108. Como esa ruta no sería correcta, sólo llegaríamos a la vista de NotFoundComponent.
:warning: Esto no es nada nuevo. Por mucho que el enrutador nos facilite crear un sistema de enrutamiento que funcione bien en toda la aplicación, y que sea único para todo el ciclo de vida de la aplicación, los enlaces relativos se basan en las mismas premisas que han funcionado desde siempre en HTML. No sólo tienes que tener en cuenta "a dónde va el enlace", si no también "desde dónde va". En realidad, aunque el enrutador de Angular pueda resultar un poco chocante la primera vez que se usa, esto son rutas relativas "de toda la vida".
Por lo demás, en la línea 5 ves como importamos el componente CustomerDataComponent, que referenciamos en la ruta. De esto casi no tendremos que preocuparnos, ya que, al escribir el nombre en la propiedad component de la ruta, VSC hace esa importación de modo automático por nosotros, pero es bueno saber que está ahí, y por qué.

### RECIBIR E IDENTIFICAR EL PARÁMETRO

Y esta es la última fase que queda (por lo menos, por ahora). ¿A dónde va ese parámetro? ¿Quién lo recibe y quién hace qué con él?. Bueno. Está claro que lo que sea ocurre en CustomerDataComponent. El parámetro, lógicamente, se recibe e identifica en la lógica de negocio, es decir, en customer-data.component.ts. Observa el siguiente código:

```ts
import { Component, OnInit } from '@angular/core';
 import { ActivatedRoute } from '@angular/router';
  @Component({
   selector: 'a02-customer-data',
   templateUrl: './customer-data.component.html',
   styleUrls: ['./customer-data.component.css']
 })
 export class CustomerDataComponent implements OnInit {
    identifier: any;
    constructor(private route: ActivatedRoute) {}
    ngOnInit() {
     //this.identifier = this.customer.snapshot.params['id'];
     route.params.subscribe(params => { this.identifier = params['id']; });
   }
 }
```

Vamos a empezar mirando la clase que se exporta, llamada CustomerDataComponent, que es la que contiene la lógica de negocio del componente. Lo primero que hacemos es definir una variable a la que he llamado `identifier`, por darle un nombre descriptivo y distintivo. En el constructor de la clase creamos una variable privada a la que hemos llamado `route`. Fíjate que la hemos definido como de tipo ActivatedRoute. Este es un tipo de dato personalizado que define Angular, y tenemos que importar la definición, como ves en la línea 2. Esta importación te la incluye el VSC automáticamente al usar el tipo pero, si tu editor no lo hace, tendrás que incluir tú la importación de forma manual. Al definir la variable como private y como un argumento del constructor, esta variable "vive" en todo el ámbito de la clase pero, al mismo tiempo, queda encapsulada de forma que evitamos que pueda ser alterada, por error, desde fuera de esta clase. Además, al quedar encapsulada en la clase, evitamos que pueda colisionar con otra variable externa que tuviera el mismo nombre. La variable identifier la dejamos sin modificador de acceso (lo que equivaldría a ponerle el modificador public), porque luego la necesitaremos ver desde fuera de la clase.
A continuación tenemos que fijarnos en la parte definida con ngOnInit. Esta es una directiva de las clases que no es, realmente de JavaScript, sino que es del propio Angular (observa que lo importamos en la línea 1). En concreto, esta detecta cuando se inicializa (se carga) el JavaScript del módulo. Detecta este evento, y responde a él con "algo" (las instrucciones contenidas en el cuerpo del evento). Para que te hagas una idea, sería (salvando las diferencias) el equivalente al `window.onload();` de JavaScript, o al `$(document).ready();` de jQuery, al menos desde el punto de vista conceptual de "algo" que se ejecuta cuando se carga el componente. Es sólo que, en Angular se llama ngOnInit, pero el concepto es el mismo.
Y aquí es donde viene la cuestión. La variable `route` lleva una propiedad `params` que es un "*observable*", al cual nos podemos *subscribir*, que es un método para tener acceso a los valores que devuelve. 

### MOSTRAR EL PARÁMETRO

Bien. Una vez que tenemos el parámetro enviado en la variable identifier, mostrarlo en la vista es una simple interpolación de variables, como ves en customer-data.component.html:

```ts
<div class="container">
   <h1>
     Ficha del cliente {{ identifier }}
   </h1>
 </div>
```

### EL RETORNO

Podemos mejorar la vista de CustomerDataComponent, con un enlace que nos devuelva a la lista de clientes. En realidad, es un enlace que debe apuntar a una ruta que ya existe (clientes), por lo que ni siquiera debemos tocar el enrutador. Sin embargo, en el enlace tenemos que añadir un pequeño retoque, que ya nos empieza a ser familiar, como ves en esta versión de customer-data.component.html:

```ts
<div class="container">
   <h1>
     Ficha del cliente {{ identifier }}
   </h1>
   <a routerLink='../../clientes'>Volver a la lista</a>
  </div>
```

Observa que el enlace sube dos niveles (../../), para poder alcanzar el path correcto en el enrutador. Esto se debe a que en la URL que tenemos ahora (mira la barra de direcciones) estamos dos niveles por debajo de la raíz del sitio, y como el enrutador está en la raíz (AppComponent), tenemos que llegar primero ahí, y luego acceder a la ruta.

## Rutas con parámetros en carga perezosa

Vamos ver el mismo proceso cuando el componente al que queremos llamar pasándole parámetros se carga en diferido (lazy load).
En realidad, el proceso es el mismo. La diferencia está en la forma de establecer las rutas y los enlaces en los que se pasan parámetros, como vamos a ver en seguida.

Con estos dos modelos en mente, entiendo que, en lo sucesivo, no tendrás dificultades para crear rutas con parámetros, sea cual sea la forma de carga de tus componentes.

### EL ENRUTADOR RAÍZ
Para ver mejor las muchas similitudes, y las pocas diferencias, vamos a hacer una cosa. El módulo de proveedores, que tenemos configurado para carga directa lo vamos a cargar en diferido. Esto, en sí, no supone mayor problema, teniendo en cuenta que, cuando creamos el módulo, lo hicimos con la opción --routing, así que ya tiene su propio enrutador. Si no fuera el caso, tendríamos que adaptar el módulo para que tuviera su enrutador interno.

Lo primero es abrir el app-routing.module.ts (el enrutador principal de la aplicación). Tenemos que buscar la línea siguiente:

```ts
import { SupplierDataComponent } from './suppliers/supplier-data/supplier-data.component';
```

Esta línea la eliminamos directamente. Puesto que el módulo de proveedores lo vamos a cargar ahora en diferido, ya no necesitamos (ni debemos) importar nada de ese módulo en el enrutador raíz.

A continuación buscamos la siguiente ruta:

```ts
{
  path: 'proveedores',
  component: SuppliersListComponent
},
y la sustituimos por:
{
  path: 'proveedores',
  loadChildren: './suppliers/suppliers.module#SuppliersModule'
},
```

Con esto ya tenemos el módulo de proveedores listo para cargarse en diferido, al menos por lo que al enrutador principal se refiere.

### EL ENRUTADOR DEL MÓDULO
En el enrutador del módulo tenemos que crear dos rutas. La ruta principal, para acceder al compomente con la lista de proveedores, y una ruta en la que se defina un parámetro, de modo que, si se activa dicha ruta, se acceda al componente de los datos de proveedor, pasándole ese parámetro. El enrutador de este módulo (suppliers-routing.module.ts), queda así:

```ts
import { NgModule } from '@angular/core';
 import { Routes, RouterModule } from '@angular/router';
 import { SuppliersListComponent } from './suppliers-list/suppliers-list.component';
 import { SupplierDataComponent } from './supplier-data/supplier-data.component';
  const routes: Routes = [
   {
     path: '',
     component: SuppliersListComponent
   },
   {
     path: ':id',
     component: SupplierDataComponent
   }
 ];
  @NgModule({
   imports: [RouterModule.forChild(routes)],
   exports: [RouterModule]
 })
 export class SuppliersRoutingModule { }
 ```

En primer lugar, observa las líneas 3 y 4, donde importamos los componentes del módulo, para poder acceder a ellos. Esto no es nada nuevo. Ya sabemos que los componentes de un módulo que se carga en diferido deben ser importados en su propio enrutador.
Ahora observa las rutas, en las líneas de la 7 a la 14. Si accedemos a la ruta vacía (lo que, dado que ya estamos en el módulo de proveedores corresponde a localhost:4200/proveedores), nos da paso al componente que muestra la lista de proveedores. Si accedemos a una ruta formada por un identificador (por ejemplo, localhost:4200/proveedores/3) nos da acceso al componente que muestra los datos de ese proveedor. Y esto, porque lo que haya a continuación de la ruta base de proveedores es tomado como un parámetro (por el signo : del path) y nos conduce a ese componente, pasándole esa parte de la ruta (el 3, en el ejemplo), como parámetro id. Hablaremos un poco más sobre este tema en este mismo artículo, pero esto nos funciona.

### EN LOS COMPONENTES DEL MÓDULO

En los componentes del módulo tenemos que hacer unos cambios muy parecidos a los que hicimos en el artículo anterior. Para empezar, en la vista de la lista de proveedores (suppliers-list.component.html) debemos incorporar los enlaces a la ruta que se activa con un parámetro, así:

```ts
<div class='container'>
   <h1>Listado de proveedores</h1>
 </div>
 <div class='container'>
   <hr>
 </div>
  <div class='container'>
   <ul>
     <li><a routerLink='1'>Proveedor 1</a></li>
     <li><a routerLink='2'>Proveedor 2</a></li>
     <li><a routerLink='3'>Proveedor 3</a></li>
     <li><a routerLink='4'>Proveedor 4</a></li>
   </ul>
 </div>
 ```

En el componente SupplierDataComponent cambiamos los archivos supplier-data.component.ts y supplier-data.component.html, así:

```ts
import { Component, OnInit } from '@angular/core';
 import { ActivatedRoute } from '@angular/router';
  @Component({
   selector: 'a02-supplier-data',
   templateUrl: './supplier-data.component.html',
   styleUrls: ['./supplier-data.component.css']
 })
 export class SupplierDataComponent implements OnInit {
    identifier: any;
    constructor(private customer: ActivatedRoute) { }
    ngOnInit() {
     this.identifier = this.customer.snapshot.params['id'];
   }
 }
```

```html
<div class="container">
   <h1>
     Ficha del Proveedor {{ identifier }}
   </h1>
   <a routerLink='../../proveedores'>Volver a la lista</a>
  </div>
```

En esto no hay novedades. Como ves, el código empleado para recuperar el parámetro y pasarlo a la vista es el mismo que en el caso de los módulos en carga diferida.

### Y SI...?
Y ¿qué ocurriría si debiéramos poder acceder, dentro de este módulo, a más de un componente al que pasarle el parámetro de identificación del proveedor?. Supongamos que, además del SupplierDataComponent, para ver los datos de un proveedor, tuviéramos un componente para modificar los datos de un proveedor, que se llamase, digamos, SupplierEditComponent. Vamos a crearlo:

`ng g c suppliers/supplierEdit --export`

Tenemos que modificar el enrutador del módulo (suppliers-routing.module.ts), así:

```ts
import { NgModule } from '@angular/core';
 import { Routes, RouterModule } from '@angular/router';
 import { SuppliersListComponent } from './suppliers-list/suppliers-list.component';
 import { SupplierDataComponent } from './supplier-data/supplier-data.component';
 import { SupplierEditComponent } from './supplier-edit/supplier-edit.component';
  const routes: Routes = [
   {
     path: '',
     component: SuppliersListComponent
   },
   {
     path: 'ver_proveedor/:id',
     component: SupplierDataComponent
   },
   {
     path: 'editar_proveedor/:id',
     component: SupplierEditComponent
   }
 ];
```

Observa, en la línea 5, que importamos el componente que acabamos de crear.
La ruta para ver los datos de un proveedor ya no puede tener, en la propiedad path, sólo el parámetro. Como ahora hay dos rutas que pueden recibir ese parámetro, debemos poder distinguirlas, como ves en las líneas de la 12 a la 19.
La vista de la lista de proveedores (suppliers-list.component.html) también debe ser modificada, para tener dos enlaces por proveedor, cada uno con su ruta (uno para acceder a la vista de datos y otro para acceder a la vista de edición).
Además, en la lógica de negocio del nuevo componente también tenemos que capturar el parámetro, y mostrarlo en la vista.
Por último, como hemos modificado las rutas, agregando un nuevo nivel, también tenemos que modificar los enlaces de "Volver a la lista".